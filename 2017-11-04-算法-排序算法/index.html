<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>排序算法 - Utopizza</title>
        <meta name="Description" content="About LoveIt Theme"><meta property="og:title" content="排序算法" />
<meta property="og:description" content="一、选择排序
输入长度为 $n$ 的数组，依次选择数组第 $i$ 小的元素，交换到数组第 $i$ 个位置。使用内外两个循环，外循环负责定位到数组第 $i$ 个位置，内循环负责从数组第 $i&#43;1$ 个位置 遍历到数组末端，记录最小的元素，交换到数组第 $i$ 个位置上。
无论输入数组元素的初始序列如何，内循环都需要迭代 $n-i$ 次，所以选择排序的总比较次数始终为 $(n-1)&#43;(n-2)&#43; \cdots &#43;2&#43;1=\frac{n(n-1)}{2} \approx \frac{n^2}{2}$ ，时间复杂度为 $O(n^2)$。
1 2 3 4 5 6 7 8 9 10 11 12 13  public class SortSelection extends Sort { public static void sort(Comparable[] a) { for (int i = 0; i &lt; a.length; i&#43;&#43;) { int minIndex = i; for (int j = i &#43; 1; j &lt; a." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" /><meta property="og:image" content="https://utopizza.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-04T16:49:00&#43;00:00" />
<meta property="article:modified_time" content="2017-11-04T16:49:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://utopizza.github.io/logo.png"/>

<meta name="twitter:title" content="排序算法"/>
<meta name="twitter:description" content="一、选择排序
输入长度为 $n$ 的数组，依次选择数组第 $i$ 小的元素，交换到数组第 $i$ 个位置。使用内外两个循环，外循环负责定位到数组第 $i$ 个位置，内循环负责从数组第 $i&#43;1$ 个位置 遍历到数组末端，记录最小的元素，交换到数组第 $i$ 个位置上。
无论输入数组元素的初始序列如何，内循环都需要迭代 $n-i$ 次，所以选择排序的总比较次数始终为 $(n-1)&#43;(n-2)&#43; \cdots &#43;2&#43;1=\frac{n(n-1)}{2} \approx \frac{n^2}{2}$ ，时间复杂度为 $O(n^2)$。
1 2 3 4 5 6 7 8 9 10 11 12 13  public class SortSelection extends Sort { public static void sort(Comparable[] a) { for (int i = 0; i &lt; a.length; i&#43;&#43;) { int minIndex = i; for (int j = i &#43; 1; j &lt; a."/>
<meta name="application-name" content="Utopizza">
<meta name="apple-mobile-web-app-title" content="Utopizza"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" /><link rel="prev" href="https://utopizza.github.io/2017-10-26-%E7%AE%97%E6%B3%95-java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/" /><link rel="next" href="https://utopizza.github.io/2017-11-08-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E5%A0%86%E5%BB%BA%E5%A0%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "排序算法",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/utopizza.github.io\/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\/"
        },"image": {
                "@type": "ImageObject",
                "url": "https:\/\/utopizza.github.io\/cover.png",
                "width":  800 ,
                "height":  600 
            },"genre": "posts","wordcount":  974 ,
        "url": "https:\/\/utopizza.github.io\/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\/","datePublished": "2017-11-04T16:49:00+00:00","dateModified": "2017-11-04T16:49:00+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
                "@type": "Organization",
                "name": "",
                "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/utopizza.github.io\/logo.png",
                "width":  127 ,
                "height":  40 
                }
            },"author": {
                "@type": "Person",
                "name": "yusheng"
            },"description": ""
    }
    </script></head>
    <body><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Utopizza"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Utopizza</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="https://github.com/utopizza" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Utopizza"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Utopizza</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="https://github.com/utopizza" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">排序算法</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>yusheng</a></span>&nbsp;
                    <span class="post-category">included in<a href="/categories/algorithm/">
                                <i class="far fa-folder fa-fw"></i>Algorithm
                            </a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i><time datetime=2017-11-04>2017-11-04</time>&nbsp;
                <i class="fas fa-pencil-alt fa-fw"></i>about 974 words&nbsp;
                <i class="far fa-clock fa-fw"></i>5 min&nbsp;</div>
        </div><div class="details toc" id="toc-static">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents"></nav></div>
            </div><div class="content" id="content"><p>一、选择排序</p>
<p>输入长度为 $n$ 的数组，依次选择数组第 $i$ 小的元素，交换到数组第 $i$ 个位置。使用内外两个循环，外循环负责定位到数组第 $i$ 个位置，内循环负责从数组第 $i+1$ 个位置 遍历到数组末端，记录最小的元素，交换到数组第 $i$ 个位置上。</p>
<p>无论输入数组元素的初始序列如何，内循环都需要迭代 $n-i$ 次，所以选择排序的总比较次数始终为 $(n-1)+(n-2)+ \cdots +2+1=\frac{n(n-1)}{2} \approx \frac{n^2}{2}$ ，时间复杂度为 $O(n^2)$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">public class SortSelection extends Sort {
    public static void sort(Comparable[] a) {
        for (int i = 0; i &lt; a.length; i++) {
            int minIndex = i;
            for (int j = i + 1; j &lt; a.length; j++) {
                if (less(a[j], a[minIndex])) {
                    minIndex = j;
                }
            }
            exchange(a, i, minIndex);
        }
    }
}
</code></pre></td></tr></table>
</div>
</div><p>二、插入排序</p>
<p>模仿扑克卡牌等的整理过程，从最左边开始，将元素逐个插入到左边有序元素序列中适当的位置。同样使用两层循环，外循环负责定位到第 $i$ 个位置，内循环负责从第 $i-1$ 到第 $1$ 个位置找到能让第 $i$ 个元素插入的合适位置（找到第一个比它小的元素时停止内循环，该元素后一个位置即为适合插入的位置）并进行插入。外循环每层迭代结束时，都保证数组从左边第 $1$ 到第 $i$ 个位置是有序的。</p>
<p>与选择排序不同，插入排序的总比较次数与输入的初始序列有关，这取决于插入排序内循环的比较次数。最好的情况就是输入的数组直接就是有序的，那么每次内循环都只需要比较一次就结束，因为合适的位置就是本身。考虑到外循环迭代 $n$ 次，因此总比较次数为 $(n-1) \cdot 1=n-1$ 次，即最好情况下时间复杂度为 $O(n)$。相反地，最坏的情况就是输入的数组是刚好逆序的，此时每次内循环都需要从第 $i-1$ 位一直比较到数组最左端的第 $1$ 位，需比较 $i-1$ 次。考虑外循环，此时总比较次数为 $0+1+\cdots+(n-1)=\frac{n(n-1)}{2} \approx \frac{n^2}{2}$，即最坏情况下时间复杂度为 $O(n^2)$。因此对局部或者全部有序的输入数组，插入排序要比选择排序快。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">public class SortInsertion extends Sort {
    public static void sort(Comparable[] a) {
        for (int i = 0; i &lt; a.length; i++) {
            for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) {
                exchange(a, j, (j - 1));
            }
        }
    }
}
</code></pre></td></tr></table>
</div>
</div><p>三、希尔排序</p>
<p>希尔排序是基于插入排序的一种改进版本。由上面分析知道，对于大规模乱序的数组，插入排序的效率是平方级别的，非常低，因为它只能一点一点地把元素从数组右边移动到左边。例如，如果最小的元素正好在数组尽头，那么将它插入正确位置就需要移动 $n-1$ 次，从数组最右边移到最左端。希尔排序为了加快速度，选择跨若干个元素交换的方式而不是相邻元素交换的方式。例如，跨 $h$ 个元素进行交互，那么一遍下来就可以保证任意间隔为 $h$ 的子数组是有序的。这样的数组被称为 $h$ 有序数组。当这些数组都有序后，开始减小 $h$，直至 $h=1$，这样整个数组便有序了。</p>
<p>至于复杂度分析，根据《算法（第四版）》一书所描述：</p>
<blockquote>
<p>透彻理解希尔排序性能至今仍然是一项挑战，也是唯一无法准确描述其对于乱序数组的性能特征的排序方式。</p>
</blockquote>
<p>但作者通过一些简单的实验，给出了一些结论：</p>
<blockquote>
<p>希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。目前最重要的结论是它的运行时间达不到平方级别。已知的最坏的情况下的比较次数和 $N^{3/2}$ 成正比。</p>
</blockquote>
<p>关于选择递增序列 $h$：</p>
<blockquote>
<p>如何选择递增序列？要回答这个问题并不简单。算法的性能不仅取决于 $h$，还取决于 $h$ 之间的数学性质，例如它们的公因子等。有很多论文研究了各种不同的递增序列，但都无法证明某个序列是“最优”的。</p>
</blockquote>
<p>书中样例代码使用的 $h$ 序列为 $3h+1$，如：1，4，13，40，&hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">public class SortShell extends Sort {
    public static void sort(Comparable[] a) {
        int len = a.length;
        int h = 1;
        while (h &lt; len / 3) 
            h = 3 * h + 1;
        while (h &gt;= 1) {
            for (int i = h; i &lt; len; i++) {
                for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) {
                    exchange(a, j, (j - h));
                }
            }
            h = h / 3;
        }
    }
}
</code></pre></td></tr></table>
</div>
</div><p>四、归并排序</p>
<p>将两个已经有序的数组，合并成一个有序数组。</p>
<p>1、归并（原地）</p>
<p>我们假设输入是一个数组 $a$，该数组的第 $lo$ 位到第 $mid$ 位，第 $mid$ 位到第 $hi$ 位分别已经有序，现在需要将两部分合并，并使使其有序，返回原数组。思路非常简单，使用辅助数组先把这两部分复制出去，然后不断比较两个部分的队头元素，谁最小谁就出队回来原数组。如果忽略新建辅助数组并复制过去的操作，显然进行归并时每个元素都只需要扫描一次。因此时间复杂度是线性的，若需要归并的元素总个数为 $n$，则时间复杂度为 $O(n)$。（注意这里仅指归并两个子数组的复杂度，不是整个完整归并排序的复杂度）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// merge a[lo..mid] and a[mid+1..hi] to a[lo...hi]
public static void merge(Comparable[] a, int lo, int mid, int hi) {
    int i = lo, j = mid + 1;
    for (int k = lo; k &lt;= hi; k++)//copy a[lo..hi] to aux[lo..hi]
        aux[k] = a[k];
    for (int k = lo; k &lt;= hi; k++)//move items back
        if (i &gt; mid)
            a[k] = aux[j++];
        else if (j &gt; hi)
            a[k] = aux[i++];
        else if (less(aux[j], aux[i]))
            a[k] = aux[j++];
        else
            a[k] = aux[i++];
}
</code></pre></td></tr></table>
</div>
</div><p>2、排序</p>
<p>有了归并操作的基础后，后面的排序就有两种选择方式：自顶向下，自底向上。</p>
<p>(1)、自顶向下</p>
<p>自顶向下的思路是，在每一层递归函数中，先把数组切分成左半边和右半边，然后把这两部分分别放给下一层递归来处理（直到切分到子数组只有一个元素为止，便返回上一层），当左右两部分都完成排序返回到本层递归时，归并这两部分，返回上一层递归。</p>
<p>至于时间复杂度，我们可以把归并排序处理过程想象成一棵树，根节点是最顶层的递归函数，对应原数组 $a[0&hellip;(n-1)]$ 的归并，这层需归并 $n$ 个元素；树的第二层是根节点的左右两个孩子，分别对应为原数组的左右两部分，左孩子处理 $a[0&hellip;\frac{n-1}{2}]$ 的归并，右孩子处理 $a[\frac{n-1}{2}+1&hellip;(n-1)]$ 的归并，因此该层也是一共需要归并 $n$ 个元素；如此一直到最底层叶节点，数组被切分成长度为2的 $\frac{n}{2}$ 个子数组：$a[0&hellip;1]，a[2..3],\cdots,a[(n-2)&hellip;(n-1)]$，该层同样共需处理 $n$ 个元素的归并。由于每层递归都是把对应子数组再分成两个子数组，因此该树是棵二叉树，树的高度为 $log_2(n)$。由上面分析知道每一层需归并处理的元素都是 $n$ 个，因此整棵树的处理代价，也即自顶向下归并排序的时间复杂度为 $O(n \cdot log_2(n))$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">public class SortMerge extends Sort {

    private static Comparable[] aux;

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        recursiveSort(a, 0, a.length - 1);
    }

    public static void recursiveSort(Comparable[] a, int lo, int hi) {
        if (lo &gt;= hi)
            return;
        int mid = lo + (hi - lo) / 2;
        recursiveSort(a, lo, mid);
        recursiveSort(a, (mid + 1), hi);
        merge(a, lo, mid, hi);
    }
}
</code></pre></td></tr></table>
</div>
</div><p>(2)、自底向上</p>
<p>自底向上的思路是，使用迭代而不是递归的方式，对数组进行两两归并，四四归并，八八归并，一直到整个数组被归并。使用两层循环，外循环迭代地改变子数组的大小：1，2，4，8，依次类推；内循环对子数组执行归并排序。</p>
<p>显然外循环共执行 $log_2(n)$ 次；对外循环的每一层，内循环需要对所有子数组总共 $n$ 个元素进行归并排序，因此自底向上归并排序的时间复杂度也是 $O(n \cdot log_2(n))$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">public class SortMergeBU extends Sort {

    private static Comparable[] aux;

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        for (int subsize = 1; subsize &lt; a.length; subsize += subsize) {
            for (int lo = 0; lo &lt; a.length - subsize; lo += subsize + subsize)
                merge(a, lo, (lo + subsize - 1), Math.min(lo + subsize + subsize - 1, a.length - 1));
        }
    }
}
</code></pre></td></tr></table>
</div>
</div><p>五、快速排序</p>
<p>快速排序是应用最广泛的排序算法，因为它实现简单，并且是原地排序，几乎不需要额外空间，同时也能做到时间复杂度为 $O(n \cdot log_2(n))$，在一般应用中，快速排序比其他排序算法都要快得多。</p>
<p>快速排序的基本思路是分治法。从输入数组中，随机地（或者有目的地）挑选某个元素，并以该元素为分界点，使用两个指针同时从数组左右两端往中间扫描，不断交换左右两边的元素，使小于分界点的元素被交换到左边，大于分界点的元素被交换到右边，直到两个指针在分界点相遇，则此一轮交换结束。此时，分界点左边的元素全部小于分界点，右边的元素全部大于分界点。接着分别对左边的数组，右边的数组重复执行如上操作，直到子数组不可再切分（子数组长度为1），此时原数组排序完成。在算法实现上非常简单，使用递归方式即可：先选择某个元素把数组切分成左右两部分，左边部分小于切分点，右边部分大于切分点。然后递归调用自己分别处理左边部分子数组和右边部分子数组（和归并排序刚好相反，归并排序是先排序好左边部分和右边部分，然后再合并两部分）。</p>
<p>快速排序对输入数据敏感，它的效率依赖于切分数组的效果，即依赖于切分元素的选择。快速排序的最好情况是每次都正好能将数组对半分，此时比较次数正好满足分治递归公式：$C_n=2 \cdot C_{n/2}+n$，其中 $2 \cdot C_{n/2}$ 表示将左右两个子数组排序的成本，$n$ 表示本层递归切分元素和所有元素比较的成本。由此公式可以推出，最好情况下快速排序的时间复杂度为 $O(n \cdot log_2(n))$（可以类比上面归并排序的树来帮助思考）。相反地，最坏情况呢？最坏情况就是每次选择的分界点元素，都是子数组最小或者最大的元素，此时把长度为 $n$ 的数组切分成长度为 $1$ 和长度为 $n-1$ 的两个子数组。此时虽然每一层递归中，切分元素和所有元素的比较次数仍然为 $n$ 次，但是递归的层数（切分次数）增加到了 $n$ 层，而不是 $log_2(n)$ 层。因此，最坏情况下快速排序的时间复杂度为 $O(n^2)$。**为了避免这种情况，一般会对输入数组进行一些预处理，例如随机打乱数组等等**。</p>
<p>可以利用树的结构来分析：设根节点大小为 $n$， 如果左右孩子结点大小均分得父结点的一半，那么这棵树将向左右同时平衡生长，最终为一棵完美平衡的二叉树，高度为 $log_2(n)$；如果左孩子只分得 $1$，右孩子分得剩余的全部，那么这棵树会一直沿着右子树生长，高度为 $n$。</p>
<p>为了简便表达基本思想，《算法（第四版）》书中给出的快速排序的代码不考虑输入数组乱序等预处理，并且每次切分只简单地选取子数组第一个元素作为切分点。作者在后面讨论了一些快速排序的高级改进，例如三取样切分等，还没时间仔细研究，等后面有空再回来补。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">public class SortQuick extends Sort {

    public static void sort(Comparable[] a) {
        //StdRandom.shuffle(a);
        sort(a, 0, (a.length - 1));
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi &lt;= lo) return;
        int j = partition(a, lo, hi);
        sort(a, lo, (j - 1));
        sort(a, (j + 1), hi);
    }

    private static int partition(Comparable[] a, int lo, int hi) {
        int i = lo, j = hi + 1;
        Comparable v = a[lo];
        while (true) {
            while (less(a[++i], v)) if (i == hi) break;
            while (less(v, a[--j])) if (j == lo) break;
            if (i &gt;= j) break;
            exchange(a, i, j);
        }
        exchange(a, lo, j);
        return j;
    }

}
</code></pre></td></tr></table>
</div>
</div><p>六、（二叉）堆排序</p>
<p>堆的定义：堆是一个数组，它可以被看成一个近似的完全二叉树，树上每个结点对应数组中的一个元素。当这棵树的每个结点都大于等于（或小于等于）它的两个孩子结点时，它被称为堆有序。父结点大于等于孩子借点时的堆称为最大堆，反之则称为最小堆。因为一个有序堆是一棵完全二叉树，因此堆中位置（即数组下标）为 $k$ 的结点，我们可以直接计算得知它的父结点位置为 $\frac{k}{2}$，它的两个孩子结点的位置为 $2k$ 和 $2k+1$。</p>
<p>建堆：输入长度为 $n$ 的数组，就是最初始的无序的堆。为了方便计算，我们先预处理输入的数组：把输入数组复制到一个新建数组 $aux[n+1]$，从 $aux[1]$ 开始放入元素，这样就不用考虑下标为 $0$ 的情况，便于利用上面的父子结点位置公式。然后，从数组的中间位置开始，往左边扫描每个元素，并调用 $sink()$ 方法往下不断调整父子结点的相对位置，如果此堆是最大堆，那么 $sink()$ 方法会使小的结点下沉，大的结点上浮。当扫描完成，则可以保证每个子堆都是父结点大于两个孩子结点，此时堆有序，建堆完成。</p>
<p>下沉排序：堆有序后，堆顶点那个元素即为数组最大元素。利用这个性质，只要在取出堆顶点后调整修复堆使其有序，然后不断重复取出堆顶点直到堆空，就可以得到有序的数组，即排序完成。那么如何取出顶点并修复堆呢？《算法（第四版）》给出的方案是，让堆顶点和堆的最后一个元素交换（其实就是取出顶点之后，用堆的最后一个元素补上，再修复），此时堆的大小减一，然后对新的顶点调用 $sink()$ 方法来修复堆的有序即可。如此这般，一直操作到堆的大小为0，则排序完成。如果该堆是最大堆，则排序的结果是升序，因为最先取出的顶点最大，放在数组最后面。</p>
<p>建堆的时间复杂度为 $O(n)$（详细推导另写一篇博客）；对于排序，每次取堆顶的时间复杂度为 $O(1)$，把最后一个元素放到堆顶并从上到下修复堆的时间复杂度为 $O(log_2(n))$，由于完成排序共需取 $n$ 次堆顶，因此排序的时间复杂度为 $O(n \cdot log_2(n))$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">public class SortHeap extends Sort {

    public static Comparable[] sort(Comparable[] a) {

        int N = a.length;

        Comparable[] aux = new Comparable[N + 1];// let index start from 1
        for (int i = 0; i &lt; N; i++) {
            aux[i + 1] = a[i];
        }

        for (int k = N / 2; k &gt;= 1; k--)
            sink(aux, k, N);
        while (N &gt; 1) {
            exchange(aux, 1, N--);
            sink(aux, 1, N);
        }

        return aux;
    }

    private static void sink(Comparable[] a, int k, int N) {
        while (k * 2 &lt;= N) {
            int j = k * 2;
            if (j &lt; N &amp;&amp; less(a[j], a[j + 1]))
                j++;
            if (!less(a[k], a[j]))
                break;
            exchange(a, k, j);
            k = j;
        }
    }

}
</code></pre></td></tr></table>
</div>
</div><p>七、基于比较的排序算法的下界</p>
<p>上面总结的选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序都是基于元素两两比较决定相对位置的排序方式。这种基于比较的排序，最好的时间复杂度为 $O(n \cdot log_2(n))$。凡是基于比较的排序都不可能有比这更小的时间复杂度。理论证明参见《算法导论》第八章第一节：排序算法的下界。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>The article was updated on 2017-11-04</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="Share on WhatsApp" data-sharer="whatsapp" data-url="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法"><i class="fab fa-line fa-fw"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="Share on Myspace" data-sharer="myspace" data-url="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a><a href="javascript:void(0);" title="Share on Blogger" data-sharer="blogger" data-url="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法" data-description=""><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="Share on Evernote" data-sharer="evernote" data-url="https://utopizza.github.io/2017-11-04-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2017-10-26-%E7%AE%97%E6%B3%95-java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/" class="prev" rel="prev" title="java位运算符优先级"><i class="fas fa-angle-left fa-fw"></i>java位运算符优先级</a>
            <a href="/2017-11-08-%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E5%A0%86%E5%BB%BA%E5%A0%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" class="next" rel="next" title="二叉堆建堆时间复杂度">二叉堆建堆时间复杂度<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.83.1">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.6"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">yusheng</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript">
    window.config = {"code":{"copyTitle":"Copy to clipboard","maxShownLines":100},"comment":{},"headerMode":{"desktop":"fixed","mobile":"auto"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};
</script><script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=html5shiv%2CElement.prototype.closest%2CrequestAnimationFrame%2CCustomEvent%2CPromise%2CObject.entries%2CObject.assign%2CObject.values%2Cfetch%2CElement.prototype.after%2CArray.prototype.fill%2CIntersectionObserver%2CArray.from%2CArray.prototype.find%2CMath.sign"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/object-fit-images/ofi.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
