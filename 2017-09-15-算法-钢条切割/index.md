# 钢条切割



一、问题：给定一段长度为 $n$ 的钢条和一个价格表 $p_i(i=1,2,...,n)$ ，求切割钢条方案，使得切割后所有钢条的总价格最大。钢条长度 $i$ 均为正整数，对应的价格为 $p_i$ :

| 长度 i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 价格 pi | 1 | 5 | 8 | 9 | 10 | 17 | 17 | 20 | 24 | 30 |


二、举例

以下用 $n$ 表示钢条长度，用 $r_n$ 表示切割长度为 $n$ 的钢条的最大总价格。

现在有一段长度为 3 的钢条，切割方案有：

- $n=3$，切割后总价：$r=8$
- $n=1+2$，切割后总价：$r=1+5=6$
- $n=1+1+1$，切割后总价：$r=1+1+1=3$
- $n=2+1$，切割后总价：$r=5+1=6$ （这种方法其实和上面第二种一样）

综上，最优的切割方案是 $n=3$，即不切割直接销售，此时 $r_3$=8

三、划分子问题，导出递推式

现在考虑每一步的切割：暂时先不考虑整条销售的情况，那么需要对钢条进行切割以取得最大销售总价格。

我们规定，每一步切割只选择一个切割点进行一次切割，这次切割只把一段钢条一分为二，分成两条更小的钢条。

对一段长度为 $n$ 的钢条，因为最小切割长度为 1（钢条长度被规定为正整数），所以对该段钢条一共有 $n-1$ 个可选择的切割点。

对该钢条，假设在第 $i$（$1 \leq i \leq n-1$） 个切割点进行切割是最优的方案。该次切割后，把该段钢条分成更小的两段：$i$ 和 $n-i$ 。因此这次切割的总价格为：

$$ r_n = r_i + r_{n-i} $$

由这条公式显然可以推出，要使 $r_n$ 最大，$r_i$ 和 $r_{n-i}$ 也应该最大，因为 $r_n$ 是它们的和。

换句话说，要使 $r_n$ 是本次切割的最大总价（最优解），那么 $r\_i$ 和 $r\_{n-i}$ 必须分别是：对长度为 $i$ 的钢条进行切割的最大价格，对长度为 $n-i$ 的钢条进行切割的最大价格。反证法证明：假设本次切割的最大价格为 $r_n$，且 $r_n = r^{'}\_i + r^{'}\_{n-i}$，其中 $r^{'}\_i$ 和 $r^{'}\_{n-i}$ 分别是切割长度为 $i$ 和 长度为 $n-i$ 的钢条的总价格，但它们并不是最大各自的最大价格。现在我们用它们的最优解 $r_i(> r^{'}\_i)$ 和 $r\_{n-i}(> r^{'}\_{n-i})$ 来替换公式中的 $r^{'}\_i$ 和 $r^{'}\_{n-i}$，将得到：$r_i + r\_{n-i} > r^{'}\_i + r^{'}\_{n-i} = r_n$，即存在比 $r_n$ 更大的总价格，与“ $r_n$是本次切割的最大价格 ”这一假设矛盾。因此如果 $r_n$ 是本次切割的最大价格，那么 $r_i$ 和 $r\_{n-i}$ 必定也是切割各自钢条的所有方案中的最大价格，否则就会存在比 $r_n$ 更优的切割方案。

考虑到长度为 $n$ 的钢条一共有 $n-1$ 个切割点，以及不切割的方案，我们可以得到每一次切割的最优方案为：

<div>
$$
r_n=
\begin{cases}
p_1, & \text{if $n=1$} \\
max ( p_n，r_1+r_{n-1}，\cdots，r_{n-1}+r_1 ), & \text{if $n>1$}
\end{cases}
$$
</div>

四、递归方法求解

按照上面的递推式，可以直接写出用递归求解的代码

```
public static int cutSteelRecursive(int[] p, int n) {
    if (n == 1)
        return p[1];
    int max = -1;
    for (int i = 1; i <= n - 1; i++) {
        int temp = cutSteelRecursive(p, i) + cutSteelRecursive(p, n - i);
        if (temp > max) max = temp;
    }
    return Math.max(p[n], max);
}

public static void main(String[] args) {
    int[] p = {0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30};
    int result = cutSteelRecursive(p, n);
    System.out.println(result);
}
```

但是用这样递归的方法会造成大量的重复计算，因为很多子问题都是重复的。如计算 $r_4$ 时，需要计算 $r_3$，$r_2$，$r_1$。其中计算 $r_3$ 时要先计算 $r_2$，$r_1$。计算好 $r_3$ 后返回最顶层，又要重新计算 $r_2$，$r_1$。

另外，长度为 $n$ 的钢条一共有 $n-1$ 个切割点，在每个切割点上，我们都可以有选择“切割”和“不切割”两种方案，所以一共有 $2^{n-1}$ 种切割方案。显然，递归的方法搜索了每一段钢条的每一个切割点的切割方案，因此复杂度为 $O(2^{n})$。

五、自底向上的动态规划

为了避免如上面递归方法对子问题重复计算，我们使用“备忘录”方法，把计算过的子问题的最优解存放到一个数组中，并从最小的子问题开始求解，再求解基于这个子问题的上一层的子问题，因此称为自底向上求解。

```
public static int cutSteelBottonUp(int[] p, int n) {
    int[] r = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        int max = -1;
        for (int j = 1; j < i; j++) {
            int temp = r[j] + r[i - j];
            if (temp > max) max = temp;
        }
        r[i] = Math.max(p[i], max);
    }
    return r[n];
}

public static void main(String[] args) {
    int[] p = {0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30};
    int result = cutSteelBottonUp(p, n);
    System.out.println(result);
}
```

使用迭代的方法，从 $r_1$ 开始逐步计算 $r_2$，$r_3$ 直到 $r_n$，在每次计算出第 $i$ 个子问题的最优解后，立即存储到数组元素 $r[i]$ 中，供后续的求解利用：`int temp = r[j] + r[i - j];`

对第 $i$ 个子问题 $r[i]$，内部循环一共执行 $i-1$ 次。当算法输入规模为 $n$ 时，总执行次数为： $0+1+2+\cdots+n-1=\frac{(n-1)^{2}}{2}$。因此对长度为 $n$ 的钢条，自底向上带备忘的迭代求解方法的复杂度为 $O(n^2)$ 。

