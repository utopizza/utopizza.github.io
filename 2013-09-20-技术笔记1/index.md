# 技术笔记(1)-C#语法小结



 
1、 camelCase规则:第一个单词以小写开头，其他每个单词开头大写，其余字母小写，如: firstName(建议使用)

2、 PascalCase规则: 每个单词除了第一个字母大写，其余小写，如: FirstName

3、 C#的布尔类型只包含true和false，不能用1和0表示，即布尔值和整数值之间不能相互转换
 
```
bool c=a>b; //若a大于b，则d为true，否则为false
```

4、 注意&&和&的区别（同||和|）：&&如果第一个操作数可判断为false，则不会继续以后的操作数而直接得出语句的值为false；||如果第一个操作数可判断为true，则不会继续以后的操作数而直接得出语句的值为true

5、 取a和b中的最大者

```
double max=(a>b)?a:b;
```

6、 整型和字符串转换

```
// 整型转字符串
int i=10;
String s=i.ToString();

// 字符串转整型
String s=“100”;
int i=Int32.Parse(s); 
```

7、 字符串转换类：Convert。需注意的是，字符串是不能改变的，如果要改变字符串的值，系统会创建一个新的字符串，而不会改变原来的字符串

8、 注意switch语句的开关性，如果某个case语句符合条件，系统会进入switch语句并一直执行到最后，除非遇到break语句才会跳出

9、 数组声明和初始化

```
int[] a=new int[10];
int[] b=new int[3]{2,4,6};
```

10、 foreach循环：对数组进行只读访问而不能做任何修改，而且不会造成数组下标越界

```
int[] b=new int[3]{2,4,6};
foreach(int m in b){ 
    Console.WriteLine(m)；// 输出数组b的每个元素
}
```

11、 一个函数可以有多条返回语句return，但有返回值类型的函数必须每种情况都有对应的返回值（特别注意含if语句的函数）

12、 函数中实参向形参的数据传递是按值传递的话，形参的数值只是从实参复制过来的一个数值，因此在函数中对形参的任何操作对实参无任何影响；如果是按应用传递的话，形参就是实参的另一个名字，两者是同一个数据，因此在函数中对形参的任何操作都是对实参的间接操作。另外，可以用ref关键字指定参数为引用参数，使按值传递变为按引用传递

```
void fun(ref int a){...};
...;
int b=10;
fun(b); // 这时，指定了a是b的引用，在fun内对a的操作会影响b
```

13、 params：可以用该关键字来化简数组参数的传递，如：

```
void fun(params int[] a){...};
...;
fun(1,2,3,4,5);
```

14、 如果要修改全局变量的值，就要使用static，因为const禁止修改变量的值。如果局部变量和全局变量同名，全局变量就会被屏蔽	

15、 C#不允许派生类的可访问性比基类（父类）更高，即内部类可以继承于一个公共类，但公共类不可以继承于一个内部类

16、 如果在定义类的时候没有指定基类，编译器就会默认该类派生于Object类，于是就可以使用Object类的方法，如：GetType()[返回从System.Type派生的类的一个实例]；ToString()[获取对象的字符串]

17、 构造函数执行顺序：为了实例化派生的类，必须先实例化它的基类。而要实例化这个基类，又必须实例化这个基类的基类，这样一直实例化到根类System.Object为止。结果是，无论使用什么构造函数实例化一个类，总是要先调用System.Object.Object()；如果对一个类使用非默认的构造函数，默认的情况是在其基类上使用匹配于这个构造函数签名的构造函数，如果找不到这样的构造函数，就使用基类的默认构造函数。（调用base关键字可以指定.NET实例化过程中使用基类中指定签名的构造函数；调用this关键字可以使当前类在调用this指定的构造函数前，先调用与this的参数匹配的非默认构造函数）

18、 定义变量时，如果使用了static关键字，则表明该变量是类的静态成员而不是对象实例的成员；定义方法时，如果使用了static关键字，该方法就只能通过类来访问，不能通过对象实例来访问（virtual方法可以重写；abstract方法必须重写；override方法重写了一个基类方法；extern方法定义字其他地方）

19、 定义属性：get创建只读属性，set创建只写属性

20、 执行接口的类必须实现接口中的所有的成员；可以使用virtual和abstract来执行接口的成员，但不能使用static和const

20、 高级转换：
    (1). 封箱和拆箱；
    (2). is运算符：检查两个类型是否兼容，是则为true；
    (3). as运算符：把一种类型转换为指定的引用类型

22、 深度复制：GetCopy()，Clone()

23、 定义委托：delegate-返回类型-委托标识符（参数表）

```
public delegate void EvenNumberHandler(int Number){...};
```

24、 定义事件：event-委托标识符-事件标识符

```
public event EvenNumberHandler OnEvenNumber;
```

25、 安装事件：用new创建一个委托实例并安装到激发事件的类中

```
public void MyEvenNumberHandler(string URL){...}; 
EvenNumberHandler HandlerInstance=new EvenNumberHandler(MyEvenNumberHandler);
```

26、 创建了委托实例后，用+=运算符（相当于注册监听器的“.”运算符）将其添加到事件变量中

```
OnEvenNumber += HandlerInstance; // 删除委托实例用 -=
```

27、 激发事件：将事件参数传递到委托方法中即可

```
EvenNumberHandler(10);
```












