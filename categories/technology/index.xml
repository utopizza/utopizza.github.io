<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technology on Utopizza</title>
    <link>https://utopizza.github.io/categories/technology/</link>
    <description>Recent content in Technology on Utopizza</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 14 Oct 2015 20:47:00 +0000</lastBuildDate>
    
	<atom:link href="https://utopizza.github.io/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>技术笔记(10)-CentOS7部署</title>
      <link>https://utopizza.github.io/posts/technique/2015-10-14-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B010/</link>
      <pubDate>Wed, 14 Oct 2015 20:47:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2015-10-14-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B010/</guid>
      <description>&lt;p&gt;0、准备：centos7镜像文件刻录成U盘系统盘&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.centos.org/download/&#34;&gt;Download CentOS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、服务器是PowerEdge R720，安装系统前要做radis磁盘阵列&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/wgp13x/p/3750957.html&#34;&gt;Dell R720上的系统安装问题的解决办法（关于RAID建立磁盘阵列的技术）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、服务器插上U盘，重启，进入BIOS设置U盘启动，安装centos7(尽量安装英文版否则路径是中文会出现乱码，可以选择安装GNOME桌面版，适用于新手)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://jingyan.baidu.com/article/a3aad71aa180e7b1fa009676.html&#34;&gt;centos7.0安装教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、配置IP,DNS,GATEWAY,NETMASK,成功之后可以上网&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.jb51.net/os/RedHat/189963.html&#34;&gt;centos下网络配置方法(网关、dns、ip地址配置)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、下载并安装LAMP(apache2/httpd，mysql/mariadb，PHP以及PHP相关组件一堆)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.howtoforge.com/apache_php_mysql_on_centos_7_lamp&#34;&gt;Install Apache, PHP And MySQL On CentOS 7 (LAMP)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、部署web网站，记得要从防火墙firewall或者iptables开放网站端口，还要留意SELinux这个东西，有可能在阻止你的网站写缓存文件，导致网站故障&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.linuxidc.com/Linux/2015-03/114749.htm&#34;&gt;CentOS 7 开放端口&lt;/a&gt;
&lt;a href=&#34;http://blog.csdn.net/yudar1024/article/details/42341041&#34;&gt;redhat7 centos7 关闭SELinux和防火墙的办法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、部署ftp网站，如果想用浏览器访问的话，需要设置允许被动模式，并且开发3000-4000端口，否则只能用ftp命令访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/lightnear/archive/2012/10/07/2713539.html&#34;&gt;CentOS配置VSFTP服务器&lt;/a&gt;
&lt;a href=&#34;http://www.cnblogs.com/qytan36/archive/2010/05/15/1736270.html&#34;&gt;为何客户端软件可以而浏览器则不能连接FTP服务器&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技术笔记(9)-MySql语法小结</title>
      <link>https://utopizza.github.io/posts/technique/2014-12-28-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B09/</link>
      <pubDate>Sun, 28 Dec 2014 18:44:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2014-12-28-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B09/</guid>
      <description>&lt;p&gt;一、数据库&lt;/p&gt;
&lt;p&gt;1.数据库的选定&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;use testDB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2.数据库的创建（后面两个是设置字符集和排序方式）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create database(if not exist) testDB (character set charset)(collate collation);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3.数据库的删除：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;drop database testDB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4.数据库的更变：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;alter database testDB(character set charset)(collate collation);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;二、数据表&lt;/p&gt;
&lt;p&gt;1.存储引擎（查看存储引擎：show engines）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ARCHIVE——插入&lt;/li&gt;
&lt;li&gt;BLACKHOLE——删除&lt;/li&gt;
&lt;li&gt;EXAMPLE——示例&lt;/li&gt;
&lt;li&gt;Falcon——事务&lt;/li&gt;
&lt;li&gt;FEDERATED——访问远程数据&lt;/li&gt;
&lt;li&gt;InnoDB——外键&lt;/li&gt;
&lt;li&gt;MEMORY——内存数据表&lt;/li&gt;
&lt;li&gt;MERGE——联合&lt;/li&gt;
&lt;li&gt;MyISAM——默认&lt;/li&gt;
&lt;li&gt;NDB——MySQL&lt;/li&gt;
&lt;li&gt;Cluster专用&lt;/li&gt;
&lt;li&gt;CSV——使用逗号分隔数据项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.数据表的创建：&lt;/p&gt;
&lt;p&gt;(1).数据表选项（选择存储引擎，否则默认为MyISAM）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table testTB( ... ) engine=InnoDB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(2).创建全新的数据表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table if not exist testTB( ... ) engine=InnoDB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(3).创建临时数据表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create temporary table testTB( ... )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(4).使用查询结果或者其它数据表创建数据表：&lt;/p&gt;
&lt;p&gt;i.如果要确保新表和原表的数据列的属性、索引都完全一致：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table testTB like exampleTB;
insert into testTB select * from exampleTB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ii.如果只要保证列名和数据一致，不需复制数据列的属性和索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table testTB select * from exampleTB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;iii.为了弥补上一点，可以使用cast()函数强制使用特定的属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table ... select cast(... as int) as ... , cast(... as char) as ... ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(5).使用MERGE数据表，设置插入方式（要联合的表必须是结构完全一致的MyISAM数据表）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table test_4( ... )  engine=MERGE union=(test_1,test_2,test_3)  insert_method=last;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(6).使用分区数据表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table testTB
(
   id int not null,
   name varchar(20) null
)
partition by range(id)
(
   partition p1 values less than 10,
   partition p2 values less than 20,
   partition p3 values less than 30,
   partition p4 values less than 40,
   partition p5 values less than MAXVALUE,
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(7).使用federated数据表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table federated_testDB( ... )  
engine=FEDERATED  
connection=&amp;#39;mysql://wys:79135QW@hostname/testDB/testTB&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了避免暴露连接字符串中的信息，可以：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create server testDB_server
foreign data wrapper mysql
options
(
  user &amp;#39;wys&amp;#39;
  password &amp;#39;79135qw&amp;#39;
  host &amp;#39;...&amp;#39;
  database &amp;#39;testDB&amp;#39;
);

create table federated_testTB( ... ) 
engine=FEDERATED
connection=&amp;#39;testDB_server/testTB&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3.数据表的删除：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;drop table if exist testTB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4.数据表的索引：&lt;/p&gt;
&lt;p&gt;(1).创建索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;// 在create内部
create table testTB( 
id int auto_increment primary key not null,
...
index index_name(id),...auto 
);

// 或者在create外部
create table testTB(...);
alter table testTB add index_name(id);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(2).删除索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;drop index index_name on testTB; 
//或者 
alter table testTB drop index index_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5.改变数据表的结构：&lt;/p&gt;
&lt;p&gt;(1).改变数据列的类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;alter table testTB modify id varchar(100); 
// 或者 
alter table testTB change id id_newname varchar(100);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(2).改变存储引擎：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;alter table testTB engine=InnoDB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(3).重新命名数据表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;alter table testTB RENAME TO new_testTB;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(4).把一个数据表从一个数据库移动到另一个数据库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;rename table testDB.testTB to testDB_2.testDB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;三、数据检索&lt;/p&gt;
&lt;p&gt;1.获取数据库的元数据（各种show）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;show database;
show tables from ...;
show colums from ... like ...;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2.利用联结操作对多表进行检索：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select ... from ...
inner/left/right/cross join ... on ...=...
where ...
group by ...
order by ...
having ...
limit ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3.使用子查询对多表进行检索：&lt;/p&gt;
&lt;p&gt;(1).in和not in：是否存在或者不存在子查询中
(2).all和any和some：all所有；any任何一个；some和any等价
(3).exist和not exist：判断子查询是否有结果集&lt;/p&gt;
&lt;p&gt;4.使用union对多表进行检索：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;(select ... from ...) 
union 
(select ... from ...) 
union 
(select ... from ...) 
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5.使用视图（可用视图完成一些必要的数学运算）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;ctreate view testView as select ... from ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;6.涉及多个数据表的删除和更新操作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;//删除表t1中id与表t2匹配的行
delete t1 from t1 inner join t2 on t1.id=t2.id;

// 删除表t1中id不与表t2匹配的行
delete t1 from t1 left join t2 on t1.id=t2.id where t2.id is null;

//同时删除表t1和表t2中id匹配的行
delete t1,t2 from t1 inner join t2 on t1.id=t2.id;

// 或者使用using
delete from t1 using t1 inner join t2 on t1.id=t2.id;
delete from t1 using t1 left join t2 on t1.id=t2.id where t2.id is null;
delete from t1,t2 using t1 inner join t2 on t1.id=t2.id;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;四、事务处理（需要使用的存储引擎是InnoDB或者Falcon）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;start transaction; // 或者set autocommit=0
insert into ...
delete from ...
commit; // set autocommit=1; 对应于上面的括号内的语句
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;1.事务的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a.原子性，事务内容要么全部成功，要么全部失败&lt;/li&gt;
&lt;li&gt;b.隔离性，事务之间是隔离的，比如在某事务向数据库插入一些数据的时候，如果事务还没结束，即使某些数据已经插入去了，但是这些数据对其他所有用户是不可见的，直到事务完成提交&lt;/li&gt;
&lt;li&gt;c.稳定性，数据在事务开始和结束后都是稳定的状态&lt;/li&gt;
&lt;li&gt;d.可靠性，如果事务执行成功，它的影响将被永久保存到数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.备注：在默认的情况下，MySQL从自动提交（autocommit）模式运行，这种模式会在每条语句执行完毕后把它当做一个事务进行提交，如果使用了 &lt;code&gt;set autocommit=0&lt;/code&gt; 语句后，这个自动提交将被禁止，这样的结果是，除非遇到一些显式提交语句（如：commit，rollback&amp;hellip;），或者隐式提交前一个事务，然后在本语句重新开始事务的DLL语句（如：alter table，create index，drop database，drop index&amp;hellip;），系统会认为接下来的所有的语句都属于一个事务&lt;/p&gt;
&lt;p&gt;3.使用事务保存点：使事务部分回滚&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table testTable(id int) engine=InnoDB;
start transaction;
insert into testTable(id) values(1);
SAVEPOINT my_savepoint;
insert into testTable(id) values(2);
rollback to SAVEPOINT my_savepoint;
insert into testTable(id) values(3);
commit;
select * from testTable;
// 此时表中的数据只有1和3，因为2被rollback了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4.事务的隔离性：InnoDB存储引擎提供4种隔离级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read uncommited——允许某个事务看到其他事务尚未提交的数据改动 read&lt;/li&gt;
&lt;li&gt;commited——只允许某个事务看到其他事务已经提交的数据改动 repeatable&lt;/li&gt;
&lt;li&gt;read（默认级别）——即使在本事务进行中，有其他事务在同时修改了数据行，本事务每次执行同一个select的结果不变&lt;/li&gt;
&lt;li&gt;serializable——更彻底的隔离，如果某个事务正在读取某些数据行，那么在它完成之前，其他事务对这些数据行不可改动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改级别：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;set global transaction isolation level ...;（全局有效）
set sessoin transaction isolation level ...;（本次会话有效）
set transaction isolation level ...;（下一次事务有效）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;5.事务问题的非事务解决方案：&lt;/p&gt;
&lt;p&gt;a.明确的锁定数据表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;LOCK tables testTable write;
select ... from ...;
update ... set ...;
UNLOCK tables;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;b.使用相对更新操作，不使用绝对更新操作（即在一个语句中，使用当前值进行差额修改的方法，而不是直接设置为一个绝对值）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;update ... set ... = ... + ... where ... 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;五、外键的创建和使用&lt;/p&gt;
&lt;p&gt;1.语法&lt;/p&gt;
&lt;p&gt;2.InnoDB存储引擎目前只能识别和支持以下外键定义语法&lt;/p&gt;
&lt;p&gt;1).constraint：用来给外键约束起一个名字
2).foreign key：列出子表的被索引数据列
3).references：列出父表和父表中的被索引数据列
4).on delete：用来设定父表里的数据行被删除时，子表中对应的数据应该发生什么事件，其子句可选择如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on delete (no action) restrict：拒绝在父表里删除那些与子表仍有数据关联的数据行（默认）&lt;/li&gt;
&lt;li&gt;on delete cascade：删除父表数据行时，子表里相关的数据行也被删除&lt;/li&gt;
&lt;li&gt;on delete set null：删除父表数据行时，子表里相关的数据行的索引列将被设置为NULL（隐含着外键不能定义为主键的意思，因为主键不能为NULL）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5).on update：同delete&lt;/p&gt;
&lt;p&gt;六、使用FULLTEXT索引&lt;/p&gt;
&lt;p&gt;七、存储过程&lt;/p&gt;
&lt;p&gt;1.复合语句和语句分隔符：使用复合语句的时候，必须先使用delimiter命令把mysql程序的语句分隔符重定义为另一个字符或字符串，它必须是存储例程里没有定义过的。在定义完了存储过程之后，切记把mysql程序的语句终止符重定义为分号&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;delimiter $（或者字符串asdfs，erer等等都可以）
create procedure test()
begin
   select ... from ... ;
end $
delimiter ;
call test();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2.存储函数（只能有一个返回值）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;delimiter $
create function test_function(id int)
returns int
reads sql data
begin
    return (select ... from ... where ...=id);
end $
delimiter ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3.存储过程（返回结果集）。和存储函数不同，存储过程不能使用在表达式里，只能通过CALL语句来调用：call test_procedure(100);
另外，存储函数不允许对调用本函数的语句正在读或写的数据表进行修改，存储过程没有这个限制，但是如果它们是从存储函数里被调用，就也需要遵守这个规则&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;delimiter $
create procedure test_procedure(id int)
begin
    select ... from ... where ...&amp;gt;=id;
end $
delimiter ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4.存储过程的参数类型（在参数名前说明）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in参数：输入的参数（默认）&lt;/li&gt;
&lt;li&gt;out参数：输出的参数（需在过程中设置变量）&lt;/li&gt;
&lt;li&gt;inout参数：输入一个值然后再输入一个值（需在过程中设置变量）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;八、触发器（触发器是与特定数据表相关联的存储过程，当相应的数据表被insert，delete，或者update语句修改时就会自动执行）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;delimiter $
create trigger test_trigger before(after) insert on testTable
    for each row begin
        if NEW.col_name(OLD.col_name) then ... ;
        end if;
    end $
delimiter ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;九、事件（定时执行预设好的数据库操作，和SQL SERVER中的作业相当）&lt;/p&gt;
&lt;p&gt;1.启用（停止）事件调度器：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;set event_scheduler=on（off）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2.查看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;show variables like &amp;#39;event_scheduler&amp;#39; ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3.创建：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create event test_event  on schedule every 4 hour
do 
delete from testTable where ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4.禁用或者开启某个事件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;alter event test_Event disable;
alter event test_Event enable;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;十、关于建表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enum(&amp;lsquo;F&amp;rsquo;,&amp;lsquo;M&amp;rsquo;)：该字段只能是F或M的枚举类型&lt;/li&gt;
&lt;li&gt;unsigned：不允许出现负数&lt;/li&gt;
&lt;li&gt;auto_increment：自增&lt;/li&gt;
&lt;li&gt;primary key(student_id)：指定主键&lt;/li&gt;
&lt;li&gt;foreign key(score_id) references - - ScoreTable(score_id)：指定外键（一般外键是其他某个表的主键）&lt;/li&gt;
&lt;li&gt;index(student_id)：指定索引&lt;/li&gt;
&lt;li&gt;engine=InnoDB：选择数据引擎为InnoDB，该引擎允许外键的使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;十一、语法：&lt;/p&gt;
&lt;p&gt;1.NULL是无数据，或未知数据，不能使用=，&amp;lt;&amp;gt;，！=来进行比较，只能用 is null 或者 is not null&lt;/p&gt;
&lt;p&gt;2.升序排列asc，降序排列desc&lt;/p&gt;
&lt;p&gt;3.设置查询显示的行数：order by &amp;hellip; desc limit 5;&lt;/p&gt;
&lt;p&gt;4.随机抽取3条数据：order by RAND() limit 3&lt;/p&gt;
&lt;p&gt;十二、模式匹配：
like，not like，%，_&lt;/p&gt;
&lt;p&gt;十三、设置和使用SQL变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select @studentName:=name from studentTable where id=1
set @studentName=&amp;#39;abc&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>技术笔记(8)-SQL多条件查询字符串拼接问题</title>
      <link>https://utopizza.github.io/posts/technique/2014-03-06-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B08/</link>
      <pubDate>Thu, 06 Mar 2014 10:18:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2014-03-06-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B08/</guid>
      <description>&lt;p&gt;一、SQL多条件查询&lt;/p&gt;
&lt;p&gt;在实现SQL的多条件查询时，一般采用的实现方法是根据传入的参数是否有效来判读是否拼接该项查询条件，如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;// 传入参数：@ProjectName=&amp;#39;rrrr&amp;#39;，@ProjectNumber=&amp;#39;123&amp;#39;

// 先写好基本查询句子
declare @sqlString varchar(100)
set @sqlString = &amp;#39;select * from Project_Info where 1=1&amp;#39;

// 拼接查询条件1
if (@ProjectName IS NOT NULL) AND (@ProjectName &amp;lt;&amp;gt; &amp;#39;&amp;#39;) 
begin
    set @sqlString = @sqlString + &amp;#39; and ProjectName like &amp;#39;&amp;#39;%&amp;#39; + @ProjectName + &amp;#39;%&amp;#39;&amp;#39;&amp;#39;
end

// 拼接查询条件2
if (@ProjectNumber IS NOT NULL) AND (@ProjectNumber &amp;lt;&amp;gt; &amp;#39;&amp;#39;)
begin
    set @sqlString = @sqlString + &amp;#39; and ProjectNumber =&amp;#39;&amp;#39;&amp;#39; + @ProjectNumber + &amp;#39;&amp;#39;&amp;#39;&amp;#39;
end
    
// 执行最终结果
exec @sqlString
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;二、问题&lt;/p&gt;
&lt;p&gt;拼接SQL时，如果不小心注意参数的引号，容易出现如下错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;set @sqlString = @sqlString + &amp;#39; and ProjectNumber =&amp;#39; + @ProjectNumber
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行报错，原因是在sql存储过程输入参数的时候，输入的rrrr，会直接赋给@ProjectName，系统不会自动给rrrr加上&#39;&amp;lsquo;两个单引号，导致最终SQL语句变成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from Project_Info where 1=1 and ProjectNumber = 123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而正确SQL的应该是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from Project_Info where 1=1 and ProjectNumber = &amp;#39;123&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;于是系统报错“列名&amp;rsquo;rrrr&amp;rsquo;无效”。解决办法：使用多个连续的单引号：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;set @sqlString = @sqlString + &amp;#39; and ProjectNumber =&amp;#39;&amp;#39;&amp;#39; + @ProjectNumber + &amp;#39;&amp;#39;&amp;#39;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;三、SQL Server中的单引号使用规则&lt;/p&gt;
&lt;p&gt;首先尽量不要在SQL中使用双引号。单引号如果要作为一个“字符串单引号”，那就在它的前面加一个单引号进行转义。即：&lt;/p&gt;
&lt;p&gt;两个连用的单引号 == 一个“字符串”意义上的单引号（即 &#39;&amp;rsquo; == &amp;quot; &#39; &amp;ldquo;）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;SQL 语句&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;执行结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;select &#39;&#39;&#39;&#39;&#39;&#39;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&#39;&amp;rsquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;select &#39; &#39;&#39; &#39;&#39; &#39;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&#39; &#39;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;select &#39; &#39;&#39;ab &#39;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lsquo;ab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;select &#39; &#39;&#39;a&#39;&#39;b &#39;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lsquo;a&amp;rsquo;b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;select &#39; &#39;&#39;a&#39;&#39;b&#39;&#39; &#39;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lsquo;a&amp;rsquo;b&amp;rsquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;技巧：拿到一个包含很多单引号的字符串（如，&lt;code&gt;&#39; and ProjectName like &#39;&#39;%&#39;&lt;/code&gt;），分析时，首先可以确定第一个和最后一个单引号都是传统的最外围的用来定义这条字符串的单引号，把它们除开后，对于内部其他多个连用的单引号，把每两个连用的单引号替换成一个“字符串单引号”即可（如，&lt;code&gt;and ProjectName like &amp;quot; &#39; &amp;quot;&lt;/code&gt;）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技术笔记(7)-标记语言、脚本语言、编程语言</title>
      <link>https://utopizza.github.io/posts/technique/2014-01-04-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B07/</link>
      <pubDate>Sat, 04 Jan 2014 13:53:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2014-01-04-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B07/</guid>
      <description>&lt;p&gt;编程语言、标记语言、脚本语言分别有哪些？区别是什么？&lt;/p&gt;
&lt;p&gt;一、标记语言&lt;/p&gt;
&lt;p&gt;是一种将文本（Text）以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码。与文本相关的其他信息（包括例如文本的结构和表示信息等）与原来的文本结合在一起，但是使用标记（markup）进行标识。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如：HTML、XML&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二、脚本语言&lt;/p&gt;
&lt;p&gt;为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。它的特点是：程序代码即是最终的执行文件，只是这个过程需要解释器的参与。脚本语言通常是被解释执行的，而且程序是文本文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如：JavaScript，Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三、解析型语言&lt;/p&gt;
&lt;p&gt;指用专门解释器对源程序逐行解释成特定平台的机器码并立即执行的语言；相当于把编译型语言的编译链接过程混到一起同时完成的。
解释型语言执行效率较低，且不能脱离解释器运行，但它的跨平台型比较容易，只需提供特定解释器即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如：Python（同时是脚本语言），Java，C#&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三、编译型语言&lt;/p&gt;
&lt;p&gt;指用专用的编译器，针对特定的操作平台（操作系统）将某种高级语言源代码一次性翻译成可被硬件平台直接运行的二进制机器码（具有操作数，指令、及相应的格式），这个过程叫做编译；编译好的可执行性文件（.exe），可在相对应的平台上运行（移植性差，但运行效率高）。有些程序编译后，还需要把其他编译好的，可能需要组装两个以上的目标代码生成最终的可执行性文件，称为链接（可实现对低层次代码的复用）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如：C、C++、Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，Java语言是一门很特殊的语言，Java程序需要进行编译步骤，但并不会生成特定平台的二进制机器码，它编译后生成的是一种与平台无关的字节码文件（*.class）（移植性好的原因），这种字节码自然不能被平台直接执行，运行时需要由解释器解释成相应平台的二进制机器码文件；大多数人认为Java是一种编译型语言，但我们说Java即是编译型语言，也是解释型语言也并没有错。&lt;/p&gt;
&lt;p&gt;四、区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标记语言没有逻辑和行为能力，不用于向计算机发出指令，常用于格式化和链接&lt;/li&gt;
&lt;li&gt;脚本语言介于标记语言和编程语言之间，脚本语言脚本语言不需要编译，可以直接用，由解释器来负责解释&lt;/li&gt;
&lt;li&gt;编译型语言写的程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;五、脚本语言与系统语言的区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抽象的级别：这是最重要也是最明显示的不同。脚本语言对程序员提供了更高级的抽象。这一点明显表现在：在这种语言自身中，存在有高级的数据结构，如列表和字典结构，和对这种结构简单方便的嵌套和操作。这样可以创建非常成功的程序&lt;/li&gt;
&lt;li&gt;类型定义：系统语言通常是强类型和静态类型定义。这就意味着所有变量的类型要在程序中指定，在编译时检查。相反地，脚本语言是最松散的类型定义，完全没有类型声明，并且在运行时进行动态类型检查&lt;/li&gt;
&lt;li&gt;执行：系统语言的特点是编译的。程序被编译成可执行的二进制。另一方面，脚本语言的特点是解释，也就是，指令被立即执行，不存在一个编译的中间状态。这就意味着脚本语言是交互式的(你可以在提示符下敲入命令，并且看到结果)，这是另一个巨大的胜利。这样完全将编译过程从编辑-编译-运行循环中去掉了。&lt;/li&gt;
&lt;li&gt;速度：以上三点是脚本语言一方面在速度与效率，另一方面在易用性与表示式的强大性之间进行折衷的典型例子。这就使得脚本语言的执行速度比系统语言慢一个数量级。这就是对脚本语言诽谤最多的方面。性能的降低不是真正的问题，因为思想是用脚本语言来组合组件，这些组件是用象C  这样的快速系统语言来编写的。所以所有需要运行快速的东西将因为是用快速的语言实现的而运行得快速。脚本语言只用于将东西绑在一起，并且这些通常不是性能的瓶颈(或如果是，你需要重新检查你的设计)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;六、本文参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/lsgsanxiao/p/5126170.html&#34;&gt;编程语言、标记语言、脚本语言分别有哪些？区别是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/zhangliangzi/article/details/50413727&#34;&gt;编译型语言、解释型语言与脚本语言三大类型详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>技术笔记(6)-SqlHelper</title>
      <link>https://utopizza.github.io/posts/technique/2013-12-21-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B06/</link>
      <pubDate>Sat, 21 Dec 2013 17:44:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2013-12-21-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B06/</guid>
      <description>&lt;p&gt;刚学ASP.NET时用的比较多的一个简单版的SqlHelper：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;using System;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace TICSystemCommon 
{
    public abstract class SqlHelper
    {
        //Database connection strings
        public static readonly string ConnectionStringShop = ConfigurationManager.ConnectionStrings[&amp;#34;ConnectionString&amp;#34;].ConnectionString;

        /// &amp;lt;param name=&amp;#34;connectionString&amp;#34;&amp;gt;a valid connection string for a SqlConnection&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandType&amp;#34;&amp;gt;the CommandType (stored procedure, text, etc.)&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandText&amp;#34;&amp;gt;the stored procedure name or T-SQL command&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandParameters&amp;#34;&amp;gt;an array of SqlParamters used to execute the command&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;an int representing the number of rows affected by the command&amp;lt;/returns&amp;gt;
        public static int ExecuteNonQuery(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                int val = cmd.ExecuteNonQuery();
                //cmd.Parameters.Clear();
                return val;
            }
        }

        /// &amp;lt;param name=&amp;#34;connectionString&amp;#34;&amp;gt;a valid connection string for a SqlConnection&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandType&amp;#34;&amp;gt;the CommandType (stored procedure, text, etc.)&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandText&amp;#34;&amp;gt;the stored procedure name or T-SQL command&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandParameters&amp;#34;&amp;gt;an array of SqlParamters used to execute the command&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;A SqlDataReader containing the results&amp;lt;/returns&amp;gt;
        public static SqlDataReader ExecuteReader(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            SqlConnection conn = new SqlConnection(connectionString);

            // we use a try/catch here because if the method throws an exception we want to 
            // close the connection throw code, because no datareader will exist, hence the 
            // commandBehaviour.CloseConnection will not work
            try
            {
                PrepareCommand(cmd, conn, null, cmdType, cmdText, commandParameters);
                SqlDataReader rdr = cmd.ExecuteReader(CommandBehavior.CloseConnection);
                //cmd.Parameters.Clear();
                return rdr;
            }
            catch(Exception e)
            {
                conn.Close();
                throw e;
            }
        }

        /// &amp;lt;param name=&amp;#34;connectionString&amp;#34;&amp;gt;a valid connection string for a SqlConnection&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandType&amp;#34;&amp;gt;the CommandType (stored procedure, text, etc.)&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandText&amp;#34;&amp;gt;the stored procedure name or T-SQL command&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;commandParameters&amp;#34;&amp;gt;an array of SqlParamters used to execute the command&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt; the first column of the first record against an existing database connection&amp;lt;/returns&amp;gt;
        public static object ExecuteScalar(string connectionString, CommandType cmdType, string cmdText, params SqlParameter[] commandParameters)
        {
            SqlCommand cmd = new SqlCommand();
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                PrepareCommand(cmd, connection, null, cmdType, cmdText, commandParameters);
                object val = cmd.ExecuteScalar();
                cmd.Parameters.Clear();
                return val;
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// Prepare a command for execution
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&amp;#34;cmd&amp;#34;&amp;gt;SqlCommand object&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;conn&amp;#34;&amp;gt;SqlConnection object&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;trans&amp;#34;&amp;gt;SqlTransaction object&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;cmdType&amp;#34;&amp;gt;Cmd type e.g. stored procedure or text&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;cmdText&amp;#34;&amp;gt;Command text, e.g. Select * from Products&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&amp;#34;cmdParms&amp;#34;&amp;gt;SqlParameters to use in the command&amp;lt;/param&amp;gt;
        private static void PrepareCommand(SqlCommand cmd, SqlConnection conn, SqlTransaction trans, CommandType cmdType, string cmdText, SqlParameter[] cmdParms)
        {

            if (conn.State != ConnectionState.Open)
                conn.Open();

            cmd.Connection = conn;
            cmd.CommandText = cmdText;

            if (trans != null)
                cmd.Transaction = trans;

            cmd.CommandType = cmdType;

            if (cmdParms != null)
            {
                foreach (SqlParameter parm in cmdParms)
                    cmd.Parameters.Add(parm);
            }
        }
    
    
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在DAL层调用SqlHelper：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;using System.Text;
using TICSystemCommon;
using TICSystemModel;
using System.Data;
using System.Data.SqlClient;

namespace TICSystemDAL
{
    public class AccidentInfoDal
    {
        
        public AccidentInfoModel GetAccidentInfoByAccidentId(int AccidentId)
        {
            AccidentInfoModel AccidentInfo = new AccidentInfoModel();
            string sql = &amp;#34;Proc_GetAccidentInfoByAccidentId&amp;#34;;
            DataTable dt = new DataTable();
            SqlParameter[] para = new SqlParameter[]
            {
                new SqlParameter(&amp;#34;@AccidentId&amp;#34;,AccidentId)
            };
            try
            {
                using (SqlDataReader dr = SqlHelper.ExecuteReader(SqlHelper.ConnectionStringShop, CommandType.StoredProcedure, sql, para))
                {
                    if (dr.Read())
                    {
                        AccidentInfo.AccidentId = Convert.ToInt32(dr[&amp;#34;AccidentId&amp;#34;].ToString());
                        AccidentInfo.AccidentPlace = dr[&amp;#34;AccidentPlace&amp;#34;].ToString();
                        AccidentInfo.AccidentTime = dr[&amp;#34;AccidentTime&amp;#34;].ToString();
                        AccidentInfo.PersonName = dr[&amp;#34;PersonName&amp;#34;].ToString();
                        AccidentInfo.PersonPhone = dr[&amp;#34;PersonPhone&amp;#34;].ToString();
                        AccidentInfo.CarNumber = dr[&amp;#34;CarNumber&amp;#34;].ToString();
                        AccidentInfo.IsDealed = Convert.ToBoolean(dr[&amp;#34;IsDealed&amp;#34;].ToString());
                    }
                }
                return AccidentInfo;
            }
            catch (Exception)
            {
                return null;
            }
        }       
        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里有个帖子说如果项目中需要考虑多线程并发和事务，则不能把数据库操作类设置成static，而是应该进行实例化来调用：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/cyq1162/p/5745325.html?utm_source=tuicool&amp;amp;utm_medium=referral#!comments&#34;&gt;不该活着的SqlHelper和DBHelper&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技术笔记(5)-表联接Join</title>
      <link>https://utopizza.github.io/posts/technique/2013-12-21-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B05/</link>
      <pubDate>Sat, 21 Dec 2013 15:14:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2013-12-21-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B05/</guid>
      <description>&lt;p&gt;数据库的常用表联接主要有inner join、left join、right join三种。&lt;/p&gt;
&lt;p&gt;例表A&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Aid&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Adate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例表B&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Bid&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Bdate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1、inner join：取出id相同的字段，仅返回两表匹配的数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from A inner join B on A.Aid = B.Bid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时的取出的是:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Aid&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Adate&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Bid&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Bdate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;2、left join：先取出“左表”A表中所有数据，然后再加上与A、B匹配的的数据。不管匹配与否，“左表”表A的全部数据将全部返回&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from a left join b on a.aid = b.bid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时的取出的是:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Aid&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Adate&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Bid&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Bdate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3、right join：先取出“右表”B表中所有数据，然后再加上与A、B匹配的的数据。不管匹配与否，“右表”B表的全部数据将全部被返回&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from a right join b on a.aid = b.bid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时的取出的是:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Aid&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Adate&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Bid&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Bdate&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;a2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;b4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;4、小结&lt;/p&gt;
&lt;p&gt;若 A join B，那么 A 为“左表”，B为“右表”。此时，
用 left join，则取左表（A）全部数据，和右表（B）匹配数据
用 right join，则取右表（B）全部数据，和左表（A）匹配数据
用 inner join，则仅取两表同时匹配数据&lt;/p&gt;
&lt;p&gt;由此，可以推断&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from A left join B on A.Aid=B.Bid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;等价于(表的内容一样，只是字段的顺序不同)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from B right join A on A.Aid=B.Bid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>技术笔记(4)-ADO.NET</title>
      <link>https://utopizza.github.io/posts/technique/2013-12-21-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B04/</link>
      <pubDate>Sat, 21 Dec 2013 12:21:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2013-12-21-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B04/</guid>
      <description>&lt;p&gt;一、ADO.NET主要用于访问数据，尤其是数据库中的数据，该类被封装在System.Data.dll中。它的两个核心组件：DataSet和.NET数据提供程序&lt;/p&gt;
&lt;p&gt;1、DataSet：记录在内存中的数据，相当于内存中的一个完整的数据集。但它并不与外部的物理数据库直接相连，而是通过DataAdapter间接的完成与外部数据库的交互。该类的主要对象有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DataTable：使用行和列形式来组织的一个矩形数据集&lt;/li&gt;
&lt;li&gt;DataColumn：列（规则的集合）&lt;/li&gt;
&lt;li&gt;DataRow：行（实际的对应于规则的数据存储）&lt;/li&gt;
&lt;li&gt;Constraint：决定能进入DataTable的数据&lt;/li&gt;
&lt;li&gt;DataRelation：不同的DataTable之间的关联&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、.NET数据提供程序：主要有4种对象，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connection：提供与数据源的连接&lt;/li&gt;
&lt;li&gt;Command：执行一系列的数据库命令&lt;/li&gt;
&lt;li&gt;DataReader：从数据源中提供高性能的数据流&lt;/li&gt;
&lt;li&gt;DataAdapter：提供连接DataSet对象和数据源的桥梁。DataAdapter通过Command对象在数据源中执行SQL命令，并将数据加载到DataSet中，使DataSet中数据的更改与数据源保持一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二、ADO.NET Connection：Connection类表示一个数据源的单个连接，但并不是单个调用。ADO.NET支持断开式连接，即可在一个Connection对象的使用过程中多次打开或关闭操作，但这些操作并不意味着该对象被创建或者销毁。主要属性有ConnectionString，ConnectionTimeOut，Database，ChangeDatabase，State等。主要的方法有：Open()，Close()。主要的状态属性有：Broken，Closed，Connecting，Executing，Fetching，Open。&lt;/p&gt;
&lt;p&gt;三、ADO.NET Command：从本质上讲，ADO.NET的Command类就是SQL命令或者是对存储过程的引用。&lt;/p&gt;
&lt;p&gt;1、主要属性有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CommandText：执行命令的内容（字符串），或者存储过程的名称&lt;/li&gt;
&lt;li&gt;CommandType：告诉Command对象怎样解释CommandText属性的内容，当该属性的值为StoredProcedure时，说明CommandText属性的内容为存储过程名称；当为TableDirect时，说明内容为表名；当为Text时，说明为SQL文本命令（即直接的sql语句）&lt;/li&gt;
&lt;li&gt;Connection：对Connection对象的引用&lt;/li&gt;
&lt;li&gt;Parameters：包含了针对CommandText属性所指定的SQL命令或存储过程的参数集合（通过函数AddRange(paras)向Command对象添加参数集）&lt;/li&gt;
&lt;li&gt;CommandTimeout：决定了命令出错前等待服务器响应的时间
Transaction：
UpdateRowSource:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、主要的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ExecuteNonQuery()：执行命令并返回受影响的行数（用于返回结果为空的sql命令或存储过程）&lt;/li&gt;
&lt;li&gt;ExecuteScalar()：执行查询并返回结果集中的第一行的第一列（用于返回单个值的sql命令或存储过程）&lt;/li&gt;
&lt;li&gt;ExecuteReader()：向Connection发送CommandText并生成DataReader（用于返回多个结果的sql命令或存储过程，该方法创建一个DataReader对象。该方法执行时可以不带参数，或者带一个参数CommandBehavior）&lt;/li&gt;
&lt;li&gt;ExecuteXmlReader()：向Connection发送CommandText并生成XmlReader&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四、DataReader：当Command对象返回结果集时，需要用DataReader来检索数据。DataReader对象返回一个来自Command对象的只读的，只能向前的数据流。DataReader每次只在内存中保留一行，所以开销非常小。&lt;/p&gt;
&lt;p&gt;1、主要属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Depth：多层结果集中，当前行的嵌套深度&lt;/li&gt;
&lt;li&gt;FieldCount：当前行的数目&lt;/li&gt;
&lt;li&gt;IsClosed：DataReader是否需要关闭&lt;/li&gt;
&lt;li&gt;Item：列值&lt;/li&gt;
&lt;li&gt;RecordsAffected：被修改，插入或者删除的行的数目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、主要方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Close()：关闭&lt;/li&gt;
&lt;li&gt;GetType()：将指定的列的值作为指定类型获取&lt;/li&gt;
&lt;li&gt;GetDataTypeName()：获取数据源类型的名称&lt;/li&gt;
&lt;li&gt;GetFieldType()：返回指定列的系统类型&lt;/li&gt;
&lt;li&gt;GetName()：获得指定列的名称&lt;/li&gt;
&lt;li&gt;GetValue()：获得指定列的值&lt;/li&gt;
&lt;li&gt;NextResult()：前进到得下一个结果&lt;/li&gt;
&lt;li&gt;Read()：前进到下一列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;五、DataAdapter：DataAdapter是DataSet和物理数据源之间的桥梁，即DataSet通过DataAdapter与数据库间接交互。DataAdapter类的目的是执行数据库查询并创建包含查询结果的DataTable，该类也可以把对DataTable的更改写回数据库。&lt;/p&gt;
&lt;p&gt;1、主要方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fill()：将查询结果填充DataSet&lt;/li&gt;
&lt;li&gt;Update()：将DataSet中的数据的变动写回数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;六、应用实例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;Sqlconnection conn=new SqlConnection();
conn.ConnectionString=&amp;#34;Server=XXX;&amp;#34;+&amp;#34;Database=XXX;&amp;#34;+&amp;#34;Intergrated Security=true;&amp;#34;;

SqlCommand cmd=new SqlCommand();
cmd.CommendText=&amp;#34;select * from studentTable&amp;#34;;
cmd.Connection=conn;

conn.Open();

DataTable dt=new DataTable();
DataSet ds=new DataSet();

SqlDataAdapter adapter=new SqlDataAdapter();
adapter.SelectCommand=cmd;
adapter.Fill(ds,&amp;#34;dt&amp;#34;);

conn.Close();

dt=ds.Tables[&amp;#34;dt&amp;#34;];
this.GridView.DataSource=dt.DefaultView;
this.GridView.DataBind();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>技术笔记(3)-C#连接数据库</title>
      <link>https://utopizza.github.io/posts/technique/2013-12-18-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B03/</link>
      <pubDate>Wed, 18 Dec 2013 23:39:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2013-12-18-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B03/</guid>
      <description>&lt;p&gt;一、创建连接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入所使用的ADO.NET类的命名空间（引入System.Data类；使用SQL Server数据库的话就要再引入System.Data.SqlClient类）&lt;/li&gt;
&lt;li&gt;创建连接字符串变量，以保存生成连接需要的信息&lt;/li&gt;
&lt;li&gt;实例化Connection&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、使用连接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开连接&lt;/li&gt;
&lt;li&gt;使用连接，主要进行读取数据，修改和删除数据等操作&lt;/li&gt;
&lt;li&gt;关闭连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三、示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;// 引入ADO.NET类的命名空间
using System.Data;
using System.Data.SqlClient;

// 创建连接字符串
string connStr = &amp;#34;server=XXX（服务器名）; database=XXX（数据库）; uid=XXX（用户名）; pwd=XXX（该用户登陆密码）;&amp;#34;
	
// 创建连接数据库的SqlConnection对象，传入连接字符串，打开连接
SqlConnection conn = new SqlConnection(connStr);
conn.Open();

// 创建要对数据库操作的SQL语句
string sql = &amp;#34;insert into subjectTable(ID,name,point) values(2,&amp;#39;物理&amp;#39;,4)&amp;#34;;

// 创建SqlCommand对象并传入SQL语句操作语句和SqlConnection连接对象
SqlCommand cmd = new SqlCommand(sql, conn);

// 调用ExecuteNonQuery()函数（执行查询语句并返回受影响的行数）
int res=cmd.ExecuteNonQuery();

// 关闭连接，返回数据
conn.Close();
return res;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;四、共享连接字符串&lt;/p&gt;
&lt;p&gt;1.打开项目的web.config文件，在connectionStrings中修改&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&amp;lt;add name=&amp;#34;connStr&amp;#34; connectionString=&amp;#34;server=xxx; database=xxx; uid=xxx; pwd=xxx;&amp;#34;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2.在原来存放连接语句的项目中引入using System.Configuration，并将原来语句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;string connStr = &amp;#34;server=xxx; database=xxx; uid=xxx; pwd=xxx;&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;string connStr = ConfigurationManager.ConnectionStrings[&amp;#34;connStr&amp;#34;].ConnectionString;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>技术笔记(2)-SQL语法小结</title>
      <link>https://utopizza.github.io/posts/technique/2013-10-23-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B02/</link>
      <pubDate>Wed, 23 Oct 2013 17:53:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2013-10-23-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B02/</guid>
      <description>&lt;p&gt;1、 Transact-SQL语言分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据定义语言（DDL）：创建，删除，修改数据表，建立索引和约束，创建其他数据库对象等&lt;/li&gt;
&lt;li&gt;数据操纵语言（DML）：查询，添加，删除，修改数据等&lt;/li&gt;
&lt;li&gt;数据控制语言（DCL）：控制安全性的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值型：int,smallint,bigint,tinyint,bit,decimal,numeric,float,real&lt;/li&gt;
&lt;li&gt;字符型：char,varchar,text&lt;/li&gt;
&lt;li&gt;日期/时间型：datetime,smalldatetime&lt;/li&gt;
&lt;li&gt;货币型：money,smallmoney&lt;/li&gt;
&lt;li&gt;二进制型：binary,varbinary,image&lt;/li&gt;
&lt;li&gt;unicode型：nchar,nvarchar,ntext&lt;/li&gt;
&lt;li&gt;sql-variant型：混合型&lt;/li&gt;
&lt;li&gt;table型：临时表&lt;/li&gt;
&lt;li&gt;自定义型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、标识符命名规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;规则标识符（符合标识符规则，不用分隔符）&lt;/li&gt;
&lt;li&gt;分隔标识符（不符合标识符规则，必须包含在&amp;rdquo; &amp;ldquo;和&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 内）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4、对象命名规则：服务器名+数据库名+所有者名+对象名，如：sever.database.owner_name.object_name&lt;/p&gt;
&lt;p&gt;5、常量：见上数据类型&lt;/p&gt;
&lt;p&gt;6、变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;//声明
DECLARE  @myint int，@mychar char(8)
	  	           
//赋值：
SET  @myint=10  
SET @mychar=&amp;#39;wang&amp;#39; 
SELECT  @myint=10，@mychar=&amp;#39;wang&amp;#39;

//查询（即输出）
SELECT  @myint  as  myint
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;7、全局变量：系统预定好的变量，只读，如：@@ERROR，@@DBTS&lt;/p&gt;
&lt;p&gt;8、算术运算：+，-，*，/，%&lt;/p&gt;
&lt;p&gt;9、逻辑运算：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;and：仅当两个都为true时返回true&lt;/li&gt;
&lt;li&gt;or：仅当两个都为false时返回false&lt;/li&gt;
&lt;li&gt;not：对布尔表达式取反&lt;/li&gt;
&lt;li&gt;all：如果全都为true，返回true&lt;/li&gt;
&lt;li&gt;any：如果有一个为true，返回true&lt;/li&gt;
&lt;li&gt;like：如果操作数与一种模式匹配，返回true&lt;/li&gt;
&lt;li&gt;in：如果操作数等于表达式列表中的一个，返回true&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;10、字符串连接符：+&lt;/p&gt;
&lt;p&gt;11、比较运算符：=，&amp;lt;，&amp;gt;，！=，&amp;lt;=，&amp;gt;=，&amp;lt;&amp;gt;（不等于）&lt;/p&gt;
&lt;p&gt;12、null与空判断：null为空值，即未知值（不是0或空字符），用操作符is来运算，而不是用比较运算符&lt;/p&gt;
&lt;p&gt;13、大对象处理：对ntext，text，image都是当作二进制大对象（BLOB）进行访问的，有专门的语句writetext，updatetext，readtext等来处理&lt;/p&gt;
&lt;p&gt;14、流程控制：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;declare @cal int
select @cal=1
while(@cal&amp;lt;5)
begin
    select @cal=@cal+1
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;15、select语句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from newstable  
select ID,title,content from newstable  
select content1 + &amp;#39; , &amp;#39; + content2 as content from newstable  
select top 10 ID from newstable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;16、where语句：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from newstable where ID = 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;17、添加排序顺序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from newstable where caID = 10 order by createTime  
select * from newstable where caID = 10 order by createTime desc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;18、添加汇总信息：（聚合函数）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select AVG(ID) from newstable  返回newstable表的ID列的平均值
select MAX(ID) from newstable  返回newstable表的ID列的最大值
select MIN(ID) from newstable  返回newstable表的ID列的最小值
select COUNT(ID) from newstable where ID&amp;lt;10  
select SUM(ID) from newstable where ID&amp;lt;10  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;19、group by语句：必须对不出现在聚合函数中的列使用该语句，否则报错。SQL要求，在含聚合函数的查询中，任何列名要么加入聚合函数中，要么包含在group by短语中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select SUM(ID),caID from newstable 
// 必须改为
select SUM(ID),caID from newstable group by caID
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;20、添加HAVING子句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select caID from newstable group by caID having min(ID)&amp;gt;7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;21、distinct：去除重复的值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select distinct caID from newstable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;22、内连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from table1 inner join table2 on table1.ID=table2.ID  返回table1和table2中所有满足table1.ID=table2.ID的行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;23、外连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select * from table1 left join table2 on table1.ID=table2.ID ;
select * from table1 right join table2 on table1.ID=table2.ID
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;24、组合字段，建立新列&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select ID * caID as ID_caID from newstable  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;25、insert语句：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;insert into newstable(title,content) values(&amp;#39;wang&amp;#39;,&amp;#39;yusheng&amp;#39;) 
insert into test select title,content,createTime from newstable where createTime&amp;lt;GETDATE()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;26、select into语句，利用已有表的字段创建新表（可作为临时表）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;select newstable.title,content,createTime into test2 from newstable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;27、update语句：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;update test set createTime=GETDATE(),content=&amp;#39;abcdefg&amp;#39; where ID=1
update test2 set createTime=GETDATE() where title not like &amp;#39;wang&amp;#39;
update test2 set content=&amp;#39;update2&amp;#39; where title in (&amp;#39;wang&amp;#39;,&amp;#39;sheng&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;28、delete语句：由于delete语句操作不可恢复，所以删除数据前最好用select into语句建立一个临时表来备份&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;delete from test where ID=1
delete from test where ID in (select ID from test group by ID having sum(ID) &amp;lt;3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;29、创建表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table categorytable
(
  ID int identity(1,1) primary key , 
  [name] varchar(20) not null default &amp;#39;abcd&amp;#39;
  ...
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;30、键：键是行标识符，能唯一的标识行和列。但键并不是独立的另一个列，它可以是表中任何一列或多个列组合来表达，但被定义为键的列不能有重复的项，必须保持其唯一性。&lt;/p&gt;
&lt;p&gt;31、主键：本表的行标识符&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table newtable(newText char(10) null primary key)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;32、外键：外键是在另一个表中出现的主键的实例&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table newstable(newsID int references category(newsID))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;33、数据规范化：设计一组表的过程叫规范化，目标是避免数据的冗余存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式：列出所有要保存的数据项，并为他们建立列名称，并把相关的列组合到表中，对每个表建立一个主键&lt;/li&gt;
&lt;li&gt;第二范式：检查每一列，将完全依赖主键的列保留，将部分依赖主键的列移到另一个新表中重新组合&lt;/li&gt;
&lt;li&gt;第三范式：存在可传递关系的列从单一的表中除去，移到单独的表中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;34、添加索引：（数据库一般自动为表中的主键建立索引）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;唯一索引：不允许两行有相同的索引，不允许重复值，没有可以引用到多行的索引条目&lt;/li&gt;
&lt;li&gt;群集索引：在其内部排序的索引，并且按照索引排序结构规定了行的存储结构（存储顺序），每张表中只能有一个群集索引，索引要求唯一&lt;/li&gt;
&lt;li&gt;非群集索引：对表中的行生成索引但不改变他们的存储顺序，索引不要求唯一&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;35、建立索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create table newstable
(
    newsText char(6) null) primary key unique(唯一索引)
    [或clustered(群集索引)，nonclustered(非群集索引)]
)
    
create table newstable(...)
create unique clustered index newsID_ind on newstable(newsID)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;36、添加约束：约束可以是主键，外键的引用，或者是数据验证的规则&lt;/p&gt;
&lt;p&gt;37、更改表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;alter table newstable add ID2 int null  
alter table newstable drop column ID2  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;38、删除表：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;drop table test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;40、创建数据库：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create database mydatabase
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;41、存储过程：存储在服务器上的查询过程称为存储过程&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;create procedure pro_test
as
	select ....
	from test
go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;42、调用存储过程：
(1) 在数据库中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;exec  pro_test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(2) 在客户端得数据控件中：设定对象，命令对象发出exec语句&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技术笔记(1)-C#语法小结</title>
      <link>https://utopizza.github.io/posts/technique/2013-09-20-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Fri, 20 Sep 2013 13:23:00 +0000</pubDate>
      
      <guid>https://utopizza.github.io/posts/technique/2013-09-20-%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B01/</guid>
      <description>&lt;p&gt;1、 camelCase规则:第一个单词以小写开头，其他每个单词开头大写，其余字母小写，如: firstName(建议使用)&lt;/p&gt;
&lt;p&gt;2、 PascalCase规则: 每个单词除了第一个字母大写，其余小写，如: FirstName&lt;/p&gt;
&lt;p&gt;3、 C#的布尔类型只包含true和false，不能用1和0表示，即布尔值和整数值之间不能相互转换&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;bool c=a&amp;gt;b; //若a大于b，则d为true，否则为false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;4、 注意&amp;amp;&amp;amp;和&amp;amp;的区别（同||和|）：&amp;amp;&amp;amp;如果第一个操作数可判断为false，则不会继续以后的操作数而直接得出语句的值为false；||如果第一个操作数可判断为true，则不会继续以后的操作数而直接得出语句的值为true&lt;/p&gt;
&lt;p&gt;5、 取a和b中的最大者&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;double max=(a&amp;gt;b)?a:b;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;6、 整型和字符串转换&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;// 整型转字符串
int i=10;
String s=i.ToString();

// 字符串转整型
String s=“100”;
int i=Int32.Parse(s); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;7、 字符串转换类：Convert。需注意的是，字符串是不能改变的，如果要改变字符串的值，系统会创建一个新的字符串，而不会改变原来的字符串&lt;/p&gt;
&lt;p&gt;8、 注意switch语句的开关性，如果某个case语句符合条件，系统会进入switch语句并一直执行到最后，除非遇到break语句才会跳出&lt;/p&gt;
&lt;p&gt;9、 数组声明和初始化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;int[] a=new int[10];
int[] b=new int[3]{2,4,6};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;10、 foreach循环：对数组进行只读访问而不能做任何修改，而且不会造成数组下标越界&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;int[] b=new int[3]{2,4,6};
foreach(int m in b){ 
    Console.WriteLine(m)；// 输出数组b的每个元素
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;11、 一个函数可以有多条返回语句return，但有返回值类型的函数必须每种情况都有对应的返回值（特别注意含if语句的函数）&lt;/p&gt;
&lt;p&gt;12、 函数中实参向形参的数据传递是按值传递的话，形参的数值只是从实参复制过来的一个数值，因此在函数中对形参的任何操作对实参无任何影响；如果是按应用传递的话，形参就是实参的另一个名字，两者是同一个数据，因此在函数中对形参的任何操作都是对实参的间接操作。另外，可以用ref关键字指定参数为引用参数，使按值传递变为按引用传递&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;void fun(ref int a){...};
...;
int b=10;
fun(b); // 这时，指定了a是b的引用，在fun内对a的操作会影响b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;13、 params：可以用该关键字来化简数组参数的传递，如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;void fun(params int[] a){...};
...;
fun(1,2,3,4,5);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;14、 如果要修改全局变量的值，就要使用static，因为const禁止修改变量的值。如果局部变量和全局变量同名，全局变量就会被屏蔽&lt;/p&gt;
&lt;p&gt;15、 C#不允许派生类的可访问性比基类（父类）更高，即内部类可以继承于一个公共类，但公共类不可以继承于一个内部类&lt;/p&gt;
&lt;p&gt;16、 如果在定义类的时候没有指定基类，编译器就会默认该类派生于Object类，于是就可以使用Object类的方法，如：GetType()[返回从System.Type派生的类的一个实例]；ToString()[获取对象的字符串]&lt;/p&gt;
&lt;p&gt;17、 构造函数执行顺序：为了实例化派生的类，必须先实例化它的基类。而要实例化这个基类，又必须实例化这个基类的基类，这样一直实例化到根类System.Object为止。结果是，无论使用什么构造函数实例化一个类，总是要先调用System.Object.Object()；如果对一个类使用非默认的构造函数，默认的情况是在其基类上使用匹配于这个构造函数签名的构造函数，如果找不到这样的构造函数，就使用基类的默认构造函数。（调用base关键字可以指定.NET实例化过程中使用基类中指定签名的构造函数；调用this关键字可以使当前类在调用this指定的构造函数前，先调用与this的参数匹配的非默认构造函数）&lt;/p&gt;
&lt;p&gt;18、 定义变量时，如果使用了static关键字，则表明该变量是类的静态成员而不是对象实例的成员；定义方法时，如果使用了static关键字，该方法就只能通过类来访问，不能通过对象实例来访问（virtual方法可以重写；abstract方法必须重写；override方法重写了一个基类方法；extern方法定义字其他地方）&lt;/p&gt;
&lt;p&gt;19、 定义属性：get创建只读属性，set创建只写属性&lt;/p&gt;
&lt;p&gt;20、 执行接口的类必须实现接口中的所有的成员；可以使用virtual和abstract来执行接口的成员，但不能使用static和const&lt;/p&gt;
&lt;p&gt;20、 高级转换：
(1). 封箱和拆箱；
(2). is运算符：检查两个类型是否兼容，是则为true；
(3). as运算符：把一种类型转换为指定的引用类型&lt;/p&gt;
&lt;p&gt;22、 深度复制：GetCopy()，Clone()&lt;/p&gt;
&lt;p&gt;23、 定义委托：delegate-返回类型-委托标识符（参数表）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;public delegate void EvenNumberHandler(int Number){...};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;24、 定义事件：event-委托标识符-事件标识符&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;public event EvenNumberHandler OnEvenNumber;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;25、 安装事件：用new创建一个委托实例并安装到激发事件的类中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;public void MyEvenNumberHandler(string URL){...}; 
EvenNumberHandler HandlerInstance=new EvenNumberHandler(MyEvenNumberHandler);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;26、 创建了委托实例后，用+=运算符（相当于注册监听器的“.”运算符）将其添加到事件变量中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;OnEvenNumber += HandlerInstance; // 删除委托实例用 -=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;27、 激发事件：将事件参数传递到委托方法中即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;EvenNumberHandler(10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>
