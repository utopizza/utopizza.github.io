<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">

    <meta name="author" content="Yusheng Wang">
    <meta name="description" content="回溯法 （Backtracking） 是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。（摘自百度百科）
此方法一般适用于求“有多少种解”的题目，如N皇后问题的“一共有多少种走法”，数独问题的“一共有多少种填法”，数组和问题的“一共有多少种组合使得数组中的某些元素之和等于目标值”等等。这种问题的特点是搜索空间很大，并且往往伴有约束条件，如N皇后问题的“每个皇后不能在同一直线上”，数独问题的“每行每列每个小九宫格都由1到9组成并且不重复”，数组和问题的“元素之和等于给定目标值”。善于利用这些约束条件，往往可以跳过大量的不可能存在解的搜索空间，极大地减少计算量。此方法也称“剪枝法”。
下面是 leetcode 的一些相关题目的解法。
一、数组和
1、Combination Sum
public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(ret,new ArrayList&lt;&gt;(),nums,target,0); return ret; } public void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int remain, int start){ if(remain&lt;0) return; else if(remain==0) soluList.add(new ArrayList(solu)); else{ for(int i=start;i&lt;nums.length;i&#43;&#43;){ solu.add(nums[i]); backtrack(soluList,solu,nums,remain-nums[i],i); solu.remove(solu.size()-1); } } } 2、Combination Sum II
public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; ret=new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(ret,new ArrayList&lt;&gt;(),nums,target,0); return ret; } private void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int remain, int start){ if(remain&lt;0) return; else if(remain==0) soluList.">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="回溯法"/>
<meta name="twitter:description" content="回溯法 （Backtracking） 是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。（摘自百度百科）
此方法一般适用于求“有多少种解”的题目，如N皇后问题的“一共有多少种走法”，数独问题的“一共有多少种填法”，数组和问题的“一共有多少种组合使得数组中的某些元素之和等于目标值”等等。这种问题的特点是搜索空间很大，并且往往伴有约束条件，如N皇后问题的“每个皇后不能在同一直线上”，数独问题的“每行每列每个小九宫格都由1到9组成并且不重复”，数组和问题的“元素之和等于给定目标值”。善于利用这些约束条件，往往可以跳过大量的不可能存在解的搜索空间，极大地减少计算量。此方法也称“剪枝法”。
下面是 leetcode 的一些相关题目的解法。
一、数组和
1、Combination Sum
public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(ret,new ArrayList&lt;&gt;(),nums,target,0); return ret; } public void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int remain, int start){ if(remain&lt;0) return; else if(remain==0) soluList.add(new ArrayList(solu)); else{ for(int i=start;i&lt;nums.length;i&#43;&#43;){ solu.add(nums[i]); backtrack(soluList,solu,nums,remain-nums[i],i); solu.remove(solu.size()-1); } } } 2、Combination Sum II
public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; ret=new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(ret,new ArrayList&lt;&gt;(),nums,target,0); return ret; } private void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int remain, int start){ if(remain&lt;0) return; else if(remain==0) soluList."/>

    <meta property="og:title" content="回溯法" />
<meta property="og:description" content="回溯法 （Backtracking） 是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。（摘自百度百科）
此方法一般适用于求“有多少种解”的题目，如N皇后问题的“一共有多少种走法”，数独问题的“一共有多少种填法”，数组和问题的“一共有多少种组合使得数组中的某些元素之和等于目标值”等等。这种问题的特点是搜索空间很大，并且往往伴有约束条件，如N皇后问题的“每个皇后不能在同一直线上”，数独问题的“每行每列每个小九宫格都由1到9组成并且不重复”，数组和问题的“元素之和等于给定目标值”。善于利用这些约束条件，往往可以跳过大量的不可能存在解的搜索空间，极大地减少计算量。此方法也称“剪枝法”。
下面是 leetcode 的一些相关题目的解法。
一、数组和
1、Combination Sum
public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(ret,new ArrayList&lt;&gt;(),nums,target,0); return ret; } public void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int remain, int start){ if(remain&lt;0) return; else if(remain==0) soluList.add(new ArrayList(solu)); else{ for(int i=start;i&lt;nums.length;i&#43;&#43;){ solu.add(nums[i]); backtrack(soluList,solu,nums,remain-nums[i],i); solu.remove(solu.size()-1); } } } 2、Combination Sum II
public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; ret=new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(ret,new ArrayList&lt;&gt;(),nums,target,0); return ret; } private void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int remain, int start){ if(remain&lt;0) return; else if(remain==0) soluList." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://utopizza.github.io/posts/algorithm/2018-01-24-%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/" />
<meta property="article:published_time" content="2018-01-24T13:57:00+00:00" />
<meta property="article:modified_time" content="2018-01-24T13:57:00+00:00" />


    
      <base href="https://utopizza.github.io/posts/algorithm/2018-01-24-%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/">
    
    <title>
  回溯法 · Utopizza
</title>

    
      <link rel="canonical" href="https://utopizza.github.io/posts/algorithm/2018-01-24-%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E6%B3%95/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.13.0/css/all.css" integrity="sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://utopizza.github.io/css/coder.min.a4f332213a21ce8eb521670c614470c58923aaaf385e2a73982c31dd7642decb.css" integrity="sha256-pPMyITohzo61IWcMYURwxYkjqq84XipzmCwx3XZC3ss=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="https://utopizza.github.io/css/coder-dark.min.e78e80fc3a585a4d1c8fc7f58623b6ff852411e38431a9cd1792877ecaa160f6.css" integrity="sha256-546A/DpYWk0cj8f1hiO2/4UkEeOEManNF5KHfsqhYPY=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="https://utopizza.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://utopizza.github.io/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.69.2" />
  </head>

  
  
    
  
  <body class="colorscheme-auto">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://utopizza.github.io/">
      Utopizza
    </a>
    
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://utopizza.github.io/about/">About</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://utopizza.github.io/posts/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://utopizza.github.io/projects/">Projects</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://utopizza.github.io/contact/">Contact me</a>
          </li>
        
      
      
    </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">回溯法</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2018-01-24T13:57:00Z'>
                January 24, 2018
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              2-minute read
            </span>
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://utopizza.github.io/categories/algorithm/">Algorithm</a></div>

          
        </div>
      </header>

      <div>
        
        <p>回溯法 （Backtracking） 是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。（摘自百度百科）</p>
<p>此方法一般适用于求“有多少种解”的题目，如N皇后问题的“一共有多少种走法”，数独问题的“一共有多少种填法”，数组和问题的“一共有多少种组合使得数组中的某些元素之和等于目标值”等等。这种问题的特点是搜索空间很大，并且往往伴有约束条件，如N皇后问题的“每个皇后不能在同一直线上”，数独问题的“每行每列每个小九宫格都由1到9组成并且不重复”，数组和问题的“元素之和等于给定目标值”。善于利用这些约束条件，往往可以跳过大量的不可能存在解的搜索空间，极大地减少计算量。此方法也称“剪枝法”。</p>
<p>下面是 leetcode 的一些相关题目的解法。</p>
<p>一、数组和</p>
<p>1、<a href="https://leetcode.com/problems/combination-sum/description/">Combination Sum</a></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) {
    List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    Arrays.sort(nums);
    backtrack(ret,new ArrayList&lt;&gt;(),nums,target,0);
    return ret;
}

public void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int remain, int start){
    if(remain&lt;0) return;
    else if(remain==0) soluList.add(new ArrayList(solu));
    else{
        for(int i=start;i&lt;nums.length;i++){
            solu.add(nums[i]);
            backtrack(soluList,solu,nums,remain-nums[i],i);
            solu.remove(solu.size()-1);
        }
    }
}
</code></pre></div><p>2、<a href="https://leetcode.com/problems/combination-sum-ii/description/">Combination Sum II</a></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) {
    List&lt;List&lt;Integer&gt;&gt; ret=new ArrayList&lt;&gt;();
    Arrays.sort(nums);
    backtrack(ret,new ArrayList&lt;&gt;(),nums,target,0);
    return ret;
}

private void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int remain, int start){
    if(remain&lt;0) return;
    else if(remain==0) soluList.add(new ArrayList(solu));
    else{
        for(int i=start;i&lt;nums.length;i++){
            if(i&gt;start&amp;&amp;nums[i-1]==nums[i]) continue;
            solu.add(nums[i]);
            backtrack(soluList,solu,nums,remain-nums[i],i+1);
            solu.remove(solu.size()-1);
        }
    }
}
</code></pre></div><p>二、子集组合</p>
<p>1、<a href="https://leetcode.com/problems/subsets/description/">Subsets</a></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; soluList=new ArrayList&lt;&gt;();
    backtrack(soluList, new ArrayList&lt;&gt;(), nums, 0);
    return soluList;
}

private void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int start){
    soluList.add(new ArrayList&lt;&gt;(solu));
    for(int i=start;i&lt;nums.length;i++){
        solu.add(nums[i]);
        backtrack(soluList,solu,nums,i+1);
        solu.remove(solu.size()-1);
    }
}
</code></pre></div><p>2、<a href="https://leetcode.com/problems/subsets-ii/description/">Subsets II</a></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; soluList=new ArrayList&lt;&gt;();
    Arrays.sort(nums);
    backtrack(soluList,new ArrayList&lt;&gt;(),nums,0);
    return soluList;
}

private void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, int start){
    soluList.add(new ArrayList&lt;&gt;(solu));
    for(int i=start;i&lt;nums.length;i++){
        if(i&gt;start&amp;&amp;nums[i-1]==nums[i]) continue;
        solu.add(nums[i]);
        backtrack(soluList,solu,nums,i+1);
        solu.remove(solu.size()-1);
    }
}
</code></pre></div><p>三、全排列</p>
<p>1、<a href="https://leetcode.com/problems/permutations/description/">Permutations</a></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; soluList=new ArrayList&lt;&gt;();
    backtrack(soluList,new ArrayList&lt;&gt;(),nums);
    return soluList;
}
    
private void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums){
    if(solu.size()==nums.length) soluList.add(new ArrayList&lt;&gt;(solu));
    else{
        for(int i=0;i&lt;nums.length;i++){
            if(solu.contains(nums[i])) continue;
            solu.add(nums[i]);
            backtrack(soluList, solu, nums);
            solu.remove(solu.size()-1);
        }
    }
}
</code></pre></div><p>2、<a href="https://leetcode.com/problems/permutations-ii/description/">Permutations II</a></p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; soluList=new ArrayList&lt;&gt;();
    Arrays.sort(nums);
    backtrack(soluList,new ArrayList&lt;&gt;(),nums,new boolean[nums.length]);
    return soluList;
}

private void backtrack(List&lt;List&lt;Integer&gt;&gt; soluList, List&lt;Integer&gt; solu, int[] nums, boolean[] used){
    if(solu.size()==nums.length) soluList.add(new ArrayList&lt;&gt;(solu));
    else{
        for(int i=0;i&lt;nums.length;i++){
            if(used[i]) continue;
            if(i&gt;0&amp;&amp;nums[i-1]==nums[i]&amp;&amp;!used[i-1]) continue;
            used[i]=true;
            solu.add(nums[i]);
            backtrack(soluList,solu,nums,used);
            solu.remove(solu.size()-1);
            used[i]=false;
        }
    }
}
</code></pre></div>
      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

    </main>

    

    

    <script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '//analytics.example.com/tracker.js', 'fathom');
fathom('set', 'siteId', 'ABCDE');
fathom('trackPageview');
</script>


  </body>

</html>
