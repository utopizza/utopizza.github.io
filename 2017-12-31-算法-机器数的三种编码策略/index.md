# 机器数的三种编码策略



一、机器数（Machine Data）与真值（True Value）

一个数在计算机中的二进制表示形式，叫做这个数的机器数。我们知道，计算机的物理结构决定了它内部只能存储 0 和 1，也即二进制数，那么计算机如何区分表示一个数的正负呢？一般上，计算机用机器数的最高位存放符号，如果最高位是 0 则表示这个数是一个正数。如果最高位是 1 则表示这个数是一个负数。假设计算机字长为 8 位（现在的计算机一般32位和64位），则 +3 转换成二进制机器数就是 0000 0011，-3 转换成二进制机器数是 1000 0011。

反过来，我们把当一个二进制数作为机器数出现时，它所代表的真实数值为机器数的真值。例如，机器数 0000 0011 的真值为 +000 0001 = +3，机器数 1000 0001 的真值为 –000 0011 = –3。

下面分别介绍原码，反码，补码，它们实际上就是机器数的三种不同的编码策略。其中，适合人脑理解和计算的是原码，而适合计算机使用的是补码。

二、原码（Primitive Encoding）

原码就是直接使用符号位和真值的绝对值的二进制数作为机器码。例如，计算机字长为 8 位时，

$$[+3]_{原}=0000 \, 0011$$

$$[-3]_{原}=1000 \, 0011$$

由于原码最高位用于表示符号，因此原码可以表示的最大正数为 0111 1111 即 +127，最小负数为 1111 1111 即 -127，因此 8 位字长的原码机器码的取值范围为 [-127, 127]。

三、反码（Invert Encoding）

反码的定义为：正数的反码等于它的原码，负数的反码等于其原码的符号位不变，其余各位取反。例如，计算机字长为 8 位时，

$$[+3]_{反}=0000 \, 0011$$

$$[-3]_{反}=1111 \, 1100$$

四、补码（Complement Encoding）

补码的定义为：正数的补码等于它的原码，负数的补码等于其原码的符号位不变，其余各位取反，再加一。例如，计算机字长为 8 位时，

$$[+3]_{补}=0000 \, 0011$$

$$[-3]_{补}=1111 \, 1101$$

五、为什么需要原码、反码、补码三种编码策略

由上面知道，对于一个正数，它的原码、反码和补码的表示是完全一样的。而对于一个负数，它的三种编码策略完全不一样。例如，计算机字长为 8 位时，

$$[+3]_{真值}=[0000\,0011]_{原}=[0000\,0011]_{反}=[0000\,0011]_{补}$$

$$[-3]_{真值}=[1000\,0011]_{原}=[1111\,1100]_{反}=[1111\,1101]_{补}$$

适合人脑直观理解的是原码，因为它就是以真值的绝对值的二进制加上一个符号位来表示，但是这样却不适合于计算机的计算。因为如果单独处理计算机中每一个机器数的符号位，会使得电路设计非常复杂。于是需要一种可以直接让符号位直接参与计算并且保证结果正确的编码方式，这就是补码被提出的原因。补码的推导具体参见：

 1. [原码, 反码, 补码 详解][1]
 2. [机器数与编码][2]

目前计算机内部使用的一般都是补码，切记。

  [1]: https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html
  [2]: http://www.tup.com.cn/upload/books/yz/026562-01.pdf

